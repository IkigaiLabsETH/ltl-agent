
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  buildProject,
  displayBanner,
  handleError,
  isGlobalInstallation,
  isRunningViaBunx,
  isRunningViaNpx,
  runBunCommand
} from "./chunk-RZ4QEERU.js";
import {
  Command
} from "./chunk-W4LNCUVN.js";
import {
  require_prompts
} from "./chunk-LRSU7IN6.js";
import {
  __toESM
} from "./chunk-567UPUC7.js";

// src/commands/update.ts
var import_prompts = __toESM(require_prompts(), 1);
import { execa } from "execa";
import { existsSync, readFileSync } from "node:fs";
import fs from "node:fs/promises";
import path, { dirname } from "node:path";
import { fileURLToPath } from "node:url";
import semver from "semver";
import { logger } from "@elizaos/core";
function getVersion() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  const packageJsonPath = path.resolve(__dirname, "../package.json");
  let version = "0.0.0";
  if (!existsSync(packageJsonPath)) {
    console.warn(`Warning: package.json not found at ${packageJsonPath}`);
  } else {
    try {
      const packageJsonContent = readFileSync(packageJsonPath, "utf8");
      const packageJson = JSON.parse(packageJsonContent);
      version = packageJson.version || "0.0.0";
    } catch (error) {
      console.error(`Error reading or parsing package.json at ${packageJsonPath}:`, error);
    }
  }
  return version;
}
function isWorkspaceVersion(versionString) {
  return versionString === "workspace:*" || versionString === "workspace" || versionString.startsWith("workspace:");
}
function isSpecialVersionTag(version) {
  const specialTags = ["beta", "latest", "next", "canary", "rc", "dev", "nightly", "alpha"];
  return specialTags.includes(version);
}
function checkVersionNeedsUpdate(currentVersion, targetVersion) {
  try {
    const cleanCurrent = String(currentVersion).replace(/^\^|~/, "");
    if (isSpecialVersionTag(cleanCurrent)) {
      return { needsUpdate: true };
    }
    if (!semver.valid(cleanCurrent) && !semver.validRange(cleanCurrent)) {
      return { needsUpdate: false, error: "Cannot determine if update needed - invalid semver" };
    }
    let versionToCompare = cleanCurrent;
    if (semver.validRange(cleanCurrent) && !semver.valid(cleanCurrent)) {
      const minVer = semver.minVersion(cleanCurrent);
      if (!minVer) {
        return { needsUpdate: false, error: "Could not determine minimum version from range" };
      }
      versionToCompare = minVer.version;
    }
    return { needsUpdate: semver.lt(versionToCompare, targetVersion) };
  } catch (error) {
    return { needsUpdate: false, error: `Version comparison error: ${error.message}` };
  }
}
function isMajorUpdate(currentVersion, targetVersion) {
  try {
    const cleanCurrent = String(currentVersion).replace(/^\^|~/, "");
    if (isSpecialVersionTag(cleanCurrent) || !semver.valid(cleanCurrent) && !semver.validRange(cleanCurrent)) {
      return false;
    }
    if (!semver.valid(targetVersion)) {
      return false;
    }
    return semver.major(targetVersion) > semver.major(cleanCurrent);
  } catch {
    return false;
  }
}
async function updateDependencies(cwd, isPlugin, dryRun = false, skipBuild = false) {
  console.info(
    `${dryRun ? "Checking" : "Updating"} ${isPlugin ? "plugin" : "project"} dependencies...`
  );
  const currentCliVersion = getVersion();
  console.info(`Current CLI version: ${currentCliVersion}`);
  try {
    const { stdout } = await execa("npm", ["view", "@elizaos/cli", "time", "--json"]);
    const timeData = JSON.parse(stdout);
    delete timeData.created;
    delete timeData.modified;
    let latestCliVersion = "";
    let latestDate = /* @__PURE__ */ new Date(0);
    for (const [version, dateString] of Object.entries(timeData)) {
      const publishDate = new Date(dateString);
      if (publishDate > latestDate) {
        latestDate = publishDate;
        latestCliVersion = version;
      }
    }
    if (!latestCliVersion) {
      latestCliVersion = currentCliVersion;
      console.info(
        `Could not determine latest version, using current CLI version: ${latestCliVersion}`
      );
    } else {
      console.info(`Latest available CLI version: ${latestCliVersion}`);
    }
    const packageJsonPath = path.join(cwd, "package.json");
    if (!existsSync(packageJsonPath)) {
      console.error("package.json not found in the current directory");
      return;
    }
    const packageJsonContent = await fs.readFile(packageJsonPath, "utf8");
    const packageJson = JSON.parse(packageJsonContent);
    const dependencies = packageJson.dependencies || {};
    const devDependencies = packageJson.devDependencies || {};
    const elizaPackages = [...Object.entries(dependencies), ...Object.entries(devDependencies)].filter(([pkg]) => pkg.startsWith("@elizaos/")).map(([pkg, version]) => ({ name: pkg, version }));
    if (elizaPackages.length === 0) {
      console.info("No ElizaOS packages found to update");
      return;
    }
    const workspacePackages = elizaPackages.filter(
      (pkg) => isWorkspaceVersion(pkg.version)
    );
    if (workspacePackages.length > 0) {
      console.info(
        `Found ${workspacePackages.length} workspace references: ${workspacePackages.map((p) => p.name).join(", ")}`
      );
      console.info(
        "Skipping update for workspace packages as they should be managed by the monorepo"
      );
      const packagesToUpdate = elizaPackages.filter(
        (pkg) => !isWorkspaceVersion(pkg.version)
      );
      if (packagesToUpdate.length === 0) {
        console.info("No non-workspace ElizaOS packages to update");
        return;
      }
      console.info(
        `Will ${dryRun ? "check" : "update"} ${packagesToUpdate.length} non-workspace packages: ${packagesToUpdate.map((p) => p.name).join(", ")}`
      );
      elizaPackages.length = 0;
      elizaPackages.push(...packagesToUpdate);
    } else {
      console.info(
        `Found ${elizaPackages.length} ElizaOS packages: ${elizaPackages.map((p) => p.name).join(", ")}`
      );
    }
    const isCLIBeta = latestCliVersion.includes("beta");
    const packageTag = isCLIBeta ? "beta" : "latest";
    console.info(`
ElizaOS packages that can be updated to @${packageTag}:`);
    let outdatedPackagesFound = false;
    for (const pkg of elizaPackages) {
      const pkgVersion = String(pkg.version).replace(/^\^|~/, "");
      const versionCheck = checkVersionNeedsUpdate(pkgVersion, latestCliVersion);
      if (versionCheck.error) {
        console.info(`  - ${pkg.name} (${pkgVersion}) \u2192 ${versionCheck.error}`);
        continue;
      }
      if (versionCheck.needsUpdate) {
        console.info(`  - ${pkg.name} (${pkgVersion}) \u2192 @${packageTag}`);
        outdatedPackagesFound = true;
      }
    }
    if (!outdatedPackagesFound) {
      console.info("All ElizaOS packages are up to date!");
      return;
    }
    if (dryRun) {
      console.info("\nTo update these packages, run the command without the --check flag");
      return;
    }
    const hasMajorUpdates = elizaPackages.some(
      (pkg) => isMajorUpdate(String(pkg.version), latestCliVersion)
    );
    if (hasMajorUpdates) {
      const { confirmMajor } = await (0, import_prompts.default)({
        type: "confirm",
        name: "confirmMajor",
        message: "Major version updates detected. This may include breaking changes. Continue?",
        initial: false
      });
      if (!confirmMajor) {
        console.info("Update canceled");
        return;
      }
    }
    const packagesNeedingUpdate = elizaPackages.filter(
      (pkg) => checkVersionNeedsUpdate(String(pkg.version), latestCliVersion).needsUpdate
    );
    if (packagesNeedingUpdate.length === 0) {
      console.info("No packages need updates.");
      return;
    }
    console.info(`Updating ${packagesNeedingUpdate.length} package(s)...`);
    for (const pkg of packagesNeedingUpdate) {
      try {
        console.info(`Updating ${pkg.name} to @${packageTag}...`);
        await runBunCommand(["add", `${pkg.name}@${packageTag}`], cwd);
      } catch (error) {
        console.error(`Failed to update ${pkg.name}@${packageTag}: ${error.message}`);
      }
    }
    console.log("Dependencies updated successfully");
    console.info("Installing updated dependencies...");
    await runBunCommand(["install"], cwd);
    if (!skipBuild) {
      console.info(`Building ${isPlugin ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin);
      console.info(`Build completed successfully`);
    } else {
      console.info("Skipping build phase as requested with --skip-build flag");
    }
  } catch (error) {
    console.error(`Error updating dependencies: ${error.message}`);
    throw error;
  }
}
function checkIfPluginDir(dir) {
  const packageJsonPath = path.join(dir, "package.json");
  if (!existsSync(packageJsonPath)) {
    return false;
  }
  try {
    const packageJsonContent = readFileSync(packageJsonPath, "utf8");
    const packageJson = JSON.parse(packageJsonContent);
    if (packageJson.name?.startsWith("@elizaos/plugin-")) {
      return true;
    }
    const keywords = packageJson.keywords || [];
    return keywords.includes("elizaos-plugin");
  } catch {
    return false;
  }
}
async function performCliUpdate() {
  try {
    const currentVersion = getVersion();
    const { stdout } = await execa("npm", ["view", "@elizaos/cli", "time", "--json"]);
    const timeData = JSON.parse(stdout);
    delete timeData.created;
    delete timeData.modified;
    let latestVersion = "";
    let latestDate = /* @__PURE__ */ new Date(0);
    for (const [version, dateString] of Object.entries(timeData)) {
      const publishDate = new Date(dateString);
      if (publishDate > latestDate) {
        latestDate = publishDate;
        latestVersion = version;
      }
    }
    if (!latestVersion || currentVersion === latestVersion) {
      await displayBanner();
      console.info("ElizaOS CLI is already up to date!");
      return true;
    }
    console.info(`Updating ElizaOS CLI from ${currentVersion} to ${latestVersion}...`);
    logger.info(`Updating Eliza CLI to version: ${latestVersion}`);
    try {
      try {
        const { stdout: stdout2, stderr } = await execa("npm", ["install", "-g", "@elizaos/cli@beta"]);
        logger.info(`Successfully updated Eliza CLI to latest version`);
        logger.info("Please restart your terminal for the changes to take effect.");
      } catch (npmError) {
        try {
          logger.info(`Beta installation failed, trying specific version: ${latestVersion}`);
          const { stdout: stdout2, stderr } = await execa("npm", [
            "install",
            "-g",
            `@elizaos/cli@${latestVersion}`
          ]);
          logger.info(`Successfully updated Eliza CLI to version ${latestVersion}`);
          logger.info("Please restart your terminal for the changes to take effect.");
        } catch (versionError) {
          throw new Error(
            `Installation of @elizaos/cli version ${latestVersion} failed. Try manually with: npm install -g @elizaos/cli@beta`
          );
        }
      }
    } catch (error) {
      logger.error("Failed to update Eliza CLI:", error.message);
      logger.info("You can try manually with: npm install -g @elizaos/cli@beta");
      process.exit(1);
    }
    await displayBanner();
    console.info("ElizaOS CLI has been successfully updated!");
    return true;
  } catch (error) {
    console.error("Failed to update ElizaOS CLI:", error);
    return false;
  }
}
var update = new Command().name("update").description("Update ElizaOS CLI and project dependencies").option("-c, --check", "Check for available updates without applying them").option("-sb, --skip-build", "Skip building after updating").option("--cli", "Update only the global CLI installation (without updating packages)").option("--packages", "Update only packages (without updating the CLI)").hook("preAction", async () => {
  try {
    await displayBanner();
  } catch (error) {
    logger.debug("Banner display failed, continuing with update");
  }
}).action(async (options) => {
  try {
    let updateCli = false;
    let updatePackages = false;
    if (!options.cli && !options.packages) {
      updateCli = true;
      updatePackages = true;
    } else {
      updateCli = !!options.cli;
      updatePackages = !!options.packages;
    }
    if (updateCli) {
      if (await isRunningViaNpx() || await isRunningViaBunx()) {
        console.warn("CLI update is not available when running via npx or bunx.");
        console.info("To install the latest version, run: npm install -g @elizaos/cli@beta");
      } else if (!await isGlobalInstallation()) {
        console.warn("The CLI update is only available for globally installed CLI.");
        console.info("To update a local installation, use your package manager manually.");
        console.info("For global installation, run: npm install -g @elizaos/cli@beta");
      } else {
        console.info("Checking for ElizaOS CLI updates...");
        try {
          const cliUpdated = await performCliUpdate();
          if (!updatePackages && cliUpdated) {
            return;
          }
        } catch (error) {
          if (!updatePackages) {
            handleError(error);
            return;
          }
          console.warn("CLI update failed, continuing with package updates...");
        }
      }
    }
    if (updatePackages) {
      const cwd = process.cwd();
      const isPlugin = checkIfPluginDir(cwd);
      console.info(`Detected ${isPlugin ? "plugin" : "project"} directory`);
      await updateDependencies(cwd, isPlugin, options.check || false, options.skipBuild || false);
      if (options.check) {
        const version = getVersion();
        console.log(`Version: ${version}`);
      } else {
        console.log(
          `${isPlugin ? "Plugin" : "Project"} successfully updated to the latest ElizaOS packages`
        );
      }
    }
  } catch (error) {
    handleError(error);
  }
});

export {
  performCliUpdate,
  update
};
