
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  character
} from "./chunk-DL5KPHCD.js";
import {
  base_exports,
  buildProject,
  copyTemplate,
  displayBanner,
  ensureElizaDir,
  handleError,
  promptAndStorePostgresUrl,
  runBunCommand,
  setupPgLite
} from "./chunk-RZ4QEERU.js";
import {
  Command
} from "./chunk-W4LNCUVN.js";
import {
  require_prompts
} from "./chunk-LRSU7IN6.js";
import {
  __toESM
} from "./chunk-567UPUC7.js";

// src/commands/create.ts
var import_prompts = __toESM(require_prompts(), 1);
import { existsSync } from "node:fs";
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { logger } from "@elizaos/core";
var initOptionsSchema = z.object({
  dir: z.string().default("."),
  yes: z.boolean().default(false),
  type: z.enum(["project", "plugin", "agent"]).default("project")
});
async function getLocalAvailableDatabases() {
  return [
    "pglite",
    "postgres"
    // "sqlite",
    // "supabase"
  ];
}
async function installDependencies(targetDir) {
  console.info("Installing dependencies...");
  try {
    await runBunCommand(["install", "--no-optional"], targetDir);
    console.log("Installed base dependencies");
  } catch (error) {
    console.warn(
      "Failed to install dependencies automatically. Please run 'bun install' manually."
    );
  }
}
async function createIgnoreFiles(targetDir) {
  const gitignorePath = path.join(targetDir, ".gitignore");
  const npmignorePath = path.join(targetDir, ".npmignore");
  if (!existsSync(gitignorePath)) {
    const gitignoreContent = `dist/
node_modules/
`;
    try {
      await fs.writeFile(gitignorePath, gitignoreContent);
    } catch (error) {
      console.error(`Failed to create .gitignore: ${error.message}`);
    }
  }
  if (!existsSync(npmignorePath)) {
    const npmignoreContent = `.turbo
dist
node_modules
.env
*.env
.env.local`;
    try {
      await fs.writeFile(npmignorePath, npmignoreContent);
    } catch (error) {
      console.error(`Failed to create .npmignore: ${error.message}`);
    }
  }
}
var create = new Command().name("create").description("Initialize a new project, plugin, or agent").option("-d, --dir <dir>", "installation directory", ".").option("-y, --yes", "skip confirmation", false).option("-t, --type <type>", "type to create (project, plugin, or agent)", "project").argument("[name]", "name for the project, plugin, or agent").action(async (name, opts) => {
  if (process.env.ELIZA_NONINTERACTIVE === "1" || process.env.ELIZA_NONINTERACTIVE === "true" || process.argv.includes("-y") || process.argv.includes("--yes")) {
    opts.yes = true;
  } else {
    opts.yes = false;
  }
  opts.yes = opts.yes === true || opts.yes === "true";
  await displayBanner();
  try {
    const initialOptions = {
      dir: opts.dir || ".",
      yes: opts.yes,
      // Already properly converted to boolean above
      type: opts.type || ""
    };
    let projectType = initialOptions.type;
    if (!projectType) {
      if (initialOptions.yes) {
        projectType = "project";
        console.info(`Using default type: ${projectType}`);
      } else {
        const { type } = await (0, import_prompts.default)({
          type: "select",
          name: "type",
          message: "What would you like to create?",
          choices: [
            { title: "Project - Contains agents and plugins", value: "project" },
            {
              title: "Plugin - Can be added to the registry and installed by others",
              value: "plugin"
            },
            {
              title: "Agent - Character definition file for an agent",
              value: "agent"
            }
          ],
          initial: 0
        });
        if (!type) {
          return;
        }
        projectType = type;
      }
    } else {
      if (!["project", "plugin", "agent"].includes(projectType)) {
        console.error(`Invalid type: ${projectType}. Must be 'project', 'plugin', or 'agent'`);
        process.exit(1);
      }
    }
    const options = initOptionsSchema.parse({
      ...initialOptions,
      type: projectType
    });
    let postgresUrl = null;
    let projectName = name;
    if (!projectName) {
      if (options.yes) {
        projectName = options.type === "plugin" ? "myplugin" : "myproject";
        console.info(`Using default name: ${projectName}`);
      } else {
        const { nameResponse } = await (0, import_prompts.default)({
          type: "text",
          name: "nameResponse",
          message: `What would you like to name your ${options.type}?`,
          validate: (value) => value.length > 0 || `${options.type} name is required`
        });
        if (!nameResponse) {
          return;
        }
        projectName = nameResponse;
      }
    }
    const validateProjectName = (name2) => {
      if (name2 === ".") {
        return true;
      }
      if (name2.includes(" ")) {
        return false;
      }
      const validNameRegex = /^[a-z0-9][-a-z0-9._]*$/;
      return validNameRegex.test(name2);
    };
    if (!validateProjectName(projectName)) {
      console.error(base_exports.red(`Error: Invalid ${options.type} name "${projectName}".`));
      console.error(`${options.type} names must follow npm package naming conventions:`);
      console.error("- Cannot contain spaces");
      console.error("- Must contain only lowercase letters, numbers, hyphens, or underscores");
      console.error("- Cannot start with a dot or underscore");
      process.exit(1);
    }
    if (options.type === "plugin") {
      if (!projectName.startsWith("plugin-")) {
        const prefixedName = `plugin-${projectName}`;
        console.info(
          `Note: Using "${prefixedName}" as the directory name to match plugin naming convention`
        );
        projectName = prefixedName;
      }
      const pluginNameRegex = /^plugin-[a-z0-9]+(-[a-z0-9]+)*$/;
      if (!pluginNameRegex.test(projectName)) {
        console.error(base_exports.red(`Error: Invalid plugin name "${projectName}".`));
        console.error("Plugin names must follow the format: plugin-[alphanumeric]");
        console.error("Examples: plugin-test, plugin-my-service, plugin-ai-tools");
        process.exit(1);
      }
    }
    const targetDir = path.join(options.dir === "." ? process.cwd() : options.dir, projectName);
    if (existsSync(targetDir)) {
      const files = await fs.readdir(targetDir);
      const isEmpty = files.length === 0 || files.every((f) => f.startsWith("."));
      if (!isEmpty) {
        console.error(
          base_exports.red(`Error: Directory "${projectName}" already exists and is not empty.`)
        );
        console.error(
          "Please choose a different name or manually remove the directory contents first."
        );
        handleError(new Error(`Directory "${projectName}" is not empty`));
        return;
      } else {
        console.info(
          `Note: Directory "${projectName}" already exists but is empty. Continuing...`
        );
      }
    }
    if (options.type === "plugin") {
      if (!existsSync(targetDir)) {
        await fs.mkdir(targetDir, { recursive: true });
      }
      const pluginName = projectName.startsWith("@elizaos/plugin-") ? projectName : `@elizaos/plugin-${projectName.replace("plugin-", "")}`;
      await copyTemplate("plugin", targetDir, pluginName);
      await createIgnoreFiles(targetDir);
      console.info("Installing dependencies...");
      try {
        await runBunCommand(["install", "--no-optional"], targetDir);
        console.log("Dependencies installed successfully!");
        if (process.env.ELIZA_NONINTERACTIVE === "1" || process.env.ELIZA_NONINTERACTIVE === "true") {
          console.log("Skipping build in non-interactive mode");
        } else {
          await buildProject(targetDir, true);
        }
      } catch (_error) {
        console.warn(
          "Failed to install dependencies automatically. Please run 'bun install' manually."
        );
      }
      console.log("Plugin initialized successfully!");
      const cdPath = options.dir === "." ? projectName : path.relative(process.cwd(), targetDir);
      console.info(
        `
Your plugin is ready! Here's your development workflow:

[1] Development
   cd ${cdPath}
   ${base_exports.cyan("elizaos dev")}                   # Start development with hot-reloading

[2] Testing
   ${base_exports.cyan("elizaos test")}                  # Run automated tests
   ${base_exports.cyan("elizaos start")}                 # Test in a live agent environment

[3] Publishing
   ${base_exports.cyan("elizaos publish --test")}        # Check registry requirements
   ${base_exports.cyan("elizaos publish")}               # Submit to registry

[?] Learn more: https://eliza.how/docs/cli/plugins`
      );
      process.stdout.write(`\x1B]1337;CurrentDir=${targetDir}\x07`);
      return;
    } else if (options.type === "agent") {
      let characterName = projectName || "MyAgent";
      const agentTemplate = { ...character };
      agentTemplate.name = characterName;
      if (agentTemplate.messageExamples) {
        agentTemplate.messageExamples.forEach((conversation) => {
          conversation.forEach((message) => {
            if (message.name === "Eliza") {
              message.name = characterName;
            }
          });
        });
      }
      let filename = characterName.endsWith(".json") ? characterName : `${characterName}.json`;
      const fullPath = path.join(process.cwd(), filename);
      await fs.writeFile(fullPath, JSON.stringify(agentTemplate, null, 2), "utf8");
      console.log(`Agent character created successfully: ${filename}`);
      console.info(
        `
You can now use this agent with:
  elizaos agent start --path ${filename}`
      );
      return;
    } else {
      if (!existsSync(targetDir)) {
        await fs.mkdir(targetDir, { recursive: true });
      }
      const availableDatabases = await getLocalAvailableDatabases();
      let database;
      if (options.yes) {
        database = "pglite";
        console.info(`Using default database: ${database}`);
      } else {
        const response = await (0, import_prompts.default)({
          type: "select",
          name: "database",
          message: "Select your database:",
          choices: availableDatabases.sort((a, b) => a.localeCompare(b)).map((db) => ({ title: db, value: db })),
          initial: availableDatabases.indexOf("pglite")
        });
        database = response.database;
      }
      if (!database) {
        console.error("No database selected or provided");
        handleError(new Error("No database selected or provided"));
        return;
      }
      await copyTemplate("project", targetDir, projectName);
      await createIgnoreFiles(targetDir);
      const projectEnvFilePath = path.join(targetDir, ".env");
      const dirs = await ensureElizaDir(targetDir);
      logger.debug("Project directories set up:", dirs);
      if (database === "pglite") {
        const projectPgliteDbDir = path.join(targetDir, ".elizadb");
        await setupPgLite(projectPgliteDbDir, projectEnvFilePath, targetDir);
        console.debug(
          `PGLite database will be stored in project directory: ${projectPgliteDbDir}`
        );
      } else if (database === "postgres" && !postgresUrl) {
        postgresUrl = await promptAndStorePostgresUrl(projectEnvFilePath);
      }
      const srcDir = path.join(targetDir, "src");
      if (!existsSync(srcDir)) {
        await fs.mkdir(srcDir);
      }
      await fs.mkdir(path.join(targetDir, "knowledge"), { recursive: true });
      await installDependencies(targetDir);
      if (process.env.ELIZA_NONINTERACTIVE === "1" || process.env.ELIZA_NONINTERACTIVE === "true") {
        console.log("Skipping build in non-interactive mode");
      } else {
        await buildProject(targetDir);
      }
      console.log("Project initialized successfully!");
      const cdPath = options.dir === "." ? projectName : path.relative(process.cwd(), targetDir);
      console.info(
        `
Your project is ready! Here's what you can do next:
1. \`cd ${cdPath}\` to change into your project directory
2. Run \`elizaos start\` to start your project
3. Visit \`http://localhost:3000\` (or your custom port) to view your project in the browser`
      );
      process.stdout.write(`\x1B]1337;CurrentDir=${targetDir}\x07`);
    }
  } catch (error) {
    handleError(error);
  }
});

export {
  create
};
