
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  AgentServer,
  jsonToCharacter,
  loadCharacterTryPath,
  startAgent,
  v4_default
} from "./chunk-IPMXNAUZ.js";
import {
  character
} from "./chunk-DL5KPHCD.js";
import {
  TestRunner,
  UserEnvironment,
  buildProject,
  promptForEnvVars,
  require_main,
  resolvePgliteDir
} from "./chunk-RZ4QEERU.js";
import {
  Command,
  Option
} from "./chunk-W4LNCUVN.js";
import {
  __toESM
} from "./chunk-567UPUC7.js";

// src/project.ts
import { logger } from "@elizaos/core";
import * as fs from "node:fs";
import path from "node:path";
function isPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return true;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return true;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return true;
    }
  }
  return false;
}
function extractPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return module;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return module.default;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return module[key];
    }
  }
  throw new Error("Could not extract plugin from module");
}
async function loadProject(dir) {
  try {
    const packageJson = JSON.parse(fs.readFileSync(path.join(dir, "package.json"), "utf8"));
    const main = packageJson.main;
    if (!main) {
      throw new Error("No main field in package.json");
    }
    const entryPoints = [
      path.join(dir, main),
      path.join(dir, "dist/index.js"),
      path.join(dir, "src/index.ts"),
      path.join(dir, "src/index.js"),
      path.join(dir, "index.ts"),
      path.join(dir, "index.js")
    ];
    let projectModule = null;
    for (const entryPoint of entryPoints) {
      if (fs.existsSync(entryPoint)) {
        try {
          const importPath = path.resolve(entryPoint);
          projectModule = await import(importPath);
          logger.info(`Loaded project from ${entryPoint}`);
          const exportKeys = Object.keys(projectModule);
          logger.debug(`Module exports: ${exportKeys.join(", ")}`);
          if (exportKeys.includes("default")) {
            logger.debug(`Default export type: ${typeof projectModule.default}`);
            if (typeof projectModule.default === "object" && projectModule.default !== null) {
              logger.debug(`Default export keys: ${Object.keys(projectModule.default).join(", ")}`);
            }
          }
          break;
        } catch (error) {
          logger.warn(`Failed to import project from ${entryPoint}:`, error);
        }
      }
    }
    if (!projectModule) {
      throw new Error("Could not find project entry point");
    }
    const moduleIsPlugin = isPlugin(projectModule);
    logger.debug(`Is this a plugin? ${moduleIsPlugin}`);
    if (moduleIsPlugin) {
      logger.info("Detected plugin module instead of project");
      try {
        const plugin = extractPlugin(projectModule);
        logger.debug(`Found plugin: ${plugin.name} - ${plugin.description}`);
        logger.debug(`Plugin has the following properties: ${Object.keys(plugin).join(", ")}`);
        const completePlugin = {
          name: plugin.name || "unknown-plugin",
          description: plugin.description || "No description",
          init: plugin.init || (async (config2, runtime) => {
            logger.info(`Dummy init for plugin: ${plugin.name}`);
          }),
          // Copy all other properties from the original plugin
          ...plugin
        };
        const testCharacter = {
          ...character,
          id: v4_default(),
          name: "Eliza (Test Mode)",
          system: `${character.system} Testing the plugin: ${completePlugin.name}.`
        };
        logger.info(`Using Eliza character as test agent for plugin: ${completePlugin.name}`);
        const testAgent = {
          character: testCharacter,
          plugins: [completePlugin],
          // Only include the plugin being tested
          init: async (runtime) => {
            logger.info(`Initializing Eliza test agent for plugin: ${completePlugin.name}`);
          }
        };
        return {
          agents: [testAgent],
          dir,
          isPlugin: true,
          pluginModule: completePlugin
        };
      } catch (error) {
        logger.error("Error extracting plugin from module:", error);
        throw error;
      }
    }
    const agents = [];
    if (projectModule.default && typeof projectModule.default === "object" && Array.isArray(projectModule.default.agents)) {
      agents.push(...projectModule.default.agents);
      logger.debug(`Found ${agents.length} agents in default export's agents array`);
    } else {
      for (const [key, value] of Object.entries(projectModule)) {
        if (key === "default" && value && typeof value === "object") {
          if (value.character && value.init) {
            agents.push(value);
            logger.debug(`Found agent in default export (single agent)`);
          }
        } else if (value && typeof value === "object" && value.character && value.init) {
          agents.push(value);
          logger.debug(`Found agent in named export: ${key}`);
        }
      }
    }
    if (agents.length === 0) {
      throw new Error("No agents found in project");
    }
    const project = {
      agents,
      dir
    };
    return project;
  } catch (error) {
    logger.error("Error loading project:", error);
    throw error;
  }
}

// src/commands/test.ts
var dotenv = __toESM(require_main(), 1);
import { exec } from "node:child_process";
import * as fs2 from "node:fs";
import { existsSync as existsSync3 } from "node:fs";
import * as net from "node:net";
import path2 from "node:path";
import { promisify } from "node:util";
import { pathToFileURL } from "url";
var execAsync = promisify(exec);
async function checkPortAvailable(port) {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.once("error", () => {
      resolve(false);
    });
    server.once("listening", () => {
      server.close();
      resolve(true);
    });
    server.listen(port);
  });
}
function checkIfLikelyPluginDir(dir) {
  return dir.includes("plugin") || existsSync3(path2.join(dir, "src/plugins.ts")) || existsSync3(path2.join(dir, "src/index.ts")) && !existsSync3(path2.join(dir, "src/agent.ts"));
}
function processFilterName(name) {
  if (!name) return void 0;
  let baseName = name.toLowerCase();
  if (baseName.endsWith(".test.ts") || baseName.endsWith(".test.js") || baseName.endsWith(".spec.ts") || baseName.endsWith(".spec.js")) {
    baseName = baseName.slice(0, -8);
  } else if (baseName.endsWith(".test") || baseName.endsWith(".spec")) {
    baseName = baseName.slice(0, -5);
  }
  return baseName;
}
async function runComponentTests(options) {
  if (!options.skipBuild) {
    try {
      const cwd = process.cwd();
      const isPlugin2 = checkIfLikelyPluginDir(cwd);
      console.info(`Building ${isPlugin2 ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin2);
      console.info(`Build completed successfully`);
    } catch (buildError) {
      console.error(`Build error: ${buildError}`);
      console.warn(`Attempting to continue with tests despite build error`);
    }
  }
  console.info("Running component tests...");
  try {
    const execa = await import("execa");
    const args = ["run", "vitest", "run"];
    if (options.name) {
      const baseName = processFilterName(options.name);
      console.info(`Using test filter: ${baseName}`);
      args.push("-t", baseName);
    }
    const { stdout, stderr } = await execa.execaCommand(`bun ${args.join(" ")}`, {
      maxBuffer: 10 * 1024 * 1024,
      shell: true
    });
    console.log(stdout);
    if (stderr) console.error(stderr);
    console.info("Component tests completed");
    if (stdout.includes("FAIL") || stderr?.includes("FAIL")) {
      return { failed: true };
    }
    return { failed: false };
  } catch (error) {
    console.error("Error running component tests:", error);
    return { failed: true };
  }
}
var runE2eTests = async (options) => {
  if (!options.skipBuild) {
    try {
      const cwd = process.cwd();
      const isPlugin2 = checkIfLikelyPluginDir(cwd);
      console.info(`Building ${isPlugin2 ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin2);
      console.info(`Build completed successfully`);
    } catch (buildError) {
      console.error(`Build error: ${buildError}`);
      console.warn(`Attempting to continue with tests despite build error`);
    }
  }
  try {
    const runtimes = [];
    const projectAgents = [];
    const elizaDir = path2.join(process.cwd(), ".eliza");
    const elizaDbDir = await resolvePgliteDir();
    const envInfo = await UserEnvironment.getInstanceInfo();
    const envFilePath = envInfo.paths.envFilePath;
    console.info("Setting up environment...");
    console.info(`Eliza directory: ${elizaDir}`);
    console.info(`Database directory: ${elizaDbDir}`);
    console.info(`Environment file: ${envFilePath}`);
    if (!fs2.existsSync(elizaDbDir)) {
      console.info(`Creating database directory: ${elizaDbDir}`);
      fs2.mkdirSync(elizaDbDir, { recursive: true });
      console.info(`Created database directory: ${elizaDbDir}`);
    }
    process.env.PGLITE_DATA_DIR = elizaDbDir;
    console.info(`Using database directory: ${elizaDbDir}`);
    if (fs2.existsSync(envFilePath)) {
      console.info(`Loading environment variables from: ${envFilePath}`);
      dotenv.config({ path: envFilePath });
      console.info("Environment variables loaded");
    } else {
      console.warn(`Environment file not found: ${envFilePath}`);
    }
    try {
      console.info("Configuring database...");
      await promptForEnvVars("pglite");
      console.info("Database configuration completed");
    } catch (error) {
      console.error("Error configuring database:", error);
      if (error instanceof Error) {
        console.error("Error details:", error.message);
        console.error("Stack trace:", error.stack);
      }
      throw error;
    }
    const postgresUrl = process.env.POSTGRES_URL;
    console.info(`PostgreSQL URL: ${postgresUrl ? "found" : "not found"}`);
    console.info("Creating server instance...");
    const server = new AgentServer();
    console.info("Server instance created");
    console.info("Waiting for database initialization...");
    console.info("Initializing server...");
    try {
      await server.initialize({
        dataDir: elizaDbDir,
        postgresUrl
      });
      console.info("Server initialized successfully");
    } catch (initError) {
      console.error("Server initialization failed:", initError);
      throw initError;
    }
    try {
      await new Promise((resolve, reject) => {
        let initializationAttempts = 0;
        const maxAttempts = 5;
        const checkInterval = setInterval(async () => {
          try {
            if (await server.database?.getConnection()) {
              clearInterval(checkInterval);
              resolve();
              return;
            }
            initializationAttempts++;
            try {
              await server.database?.init();
              clearInterval(checkInterval);
              resolve();
            } catch (initError) {
              console.warn(
                `Database initialization attempt ${initializationAttempts}/${maxAttempts} failed:`,
                initError
              );
              if (initializationAttempts >= maxAttempts) {
                if (await server.database?.getConnection()) {
                  console.warn(
                    "Max initialization attempts reached, but database connection exists. Proceeding anyway."
                  );
                  clearInterval(checkInterval);
                  resolve();
                } else {
                  clearInterval(checkInterval);
                  reject(new Error(`Database initialization failed after ${maxAttempts} attempts`));
                }
              }
            }
          } catch (error) {
            console.error("Error during database initialization check:", error);
            if (error instanceof Error) {
              console.error("Error details:", error.message);
              console.error("Stack trace:", error.stack);
            }
            clearInterval(checkInterval);
            reject(error);
          }
        }, 1e3);
        setTimeout(async () => {
          clearInterval(checkInterval);
          if (await server.database?.getConnection()) {
            console.warn(
              "Database initialization timeout, but connection exists. Proceeding anyway."
            );
            resolve();
          } else {
            reject(new Error("Database initialization timed out after 30 seconds"));
          }
        }, 3e4);
      });
      console.info("Database initialized successfully");
    } catch (error) {
      console.error("Failed to initialize database:", error);
      if (error instanceof Error) {
        console.error("Error details:", error.message);
        console.error("Stack trace:", error.stack);
      }
      throw error;
    }
    console.info("Setting up server properties...");
    server.startAgent = async (character2) => {
      console.info(`Starting agent for character ${character2.name}`);
      return startAgent(character2, server);
    };
    server.loadCharacterTryPath = loadCharacterTryPath;
    server.jsonToCharacter = jsonToCharacter;
    console.info("Server properties set up");
    const serverPort = options.port || Number.parseInt(process.env.SERVER_PORT || "3000");
    let project;
    try {
      console.info("Attempting to load project or plugin...");
      try {
        project = await loadProject(process.cwd());
        if (project.isPlugin) {
          console.info(`Plugin loaded successfully: ${project.pluginModule?.name}`);
        } else {
          console.info("Project loaded successfully");
        }
        if (!project || !project.agents || project.agents.length === 0) {
          throw new Error("No agents found in project configuration");
        }
        console.info(
          `Found ${project.agents.length} agents in ${project.isPlugin ? "plugin" : "project"} configuration`
        );
      } catch (loadError) {
        console.error("Error loading project/plugin:", loadError);
        const distIndexPath = path2.join(process.cwd(), "dist", "index.js");
        if (fs2.existsSync(distIndexPath)) {
          try {
            console.info(`Attempting to load project from dist/index.js instead...`);
            const distModule = await import(pathToFileURL(distIndexPath).href);
            if (distModule && (distModule.default || distModule.character || distModule.plugin)) {
              console.info(`Successfully loaded project from dist/index.js`);
              project = {
                isPlugin: Boolean(distModule.plugin || distModule.default?.plugin),
                agents: [
                  {
                    character: distModule.character || distModule.default?.character || { name: "Test Character" },
                    plugins: distModule.plugin ? [distModule.plugin] : distModule.default?.plugin ? [distModule.default.plugin] : []
                  }
                ]
              };
              console.info(`Created project with ${project.agents.length} agents`);
            } else {
              throw new Error(`dist/index.js exists but doesn't export expected properties`);
            }
          } catch (distError) {
            console.error(`Failed to load from dist/index.js:`, distError);
            throw loadError;
          }
        } else {
          console.error("Tests cannot run without a valid project or plugin. Exiting.");
          if (loadError instanceof Error) {
            if (loadError.message.includes("Could not find project entry point")) {
              console.error("No Eliza project or plugin found in current directory.");
              console.error("Tests can only run in a valid Eliza project or plugin directory.");
            }
            console.error("Error details:", loadError.message);
          }
          process.exit(1);
        }
      }
      console.info("Starting server...");
      try {
        if (!await checkPortAvailable(serverPort)) {
          console.error(`Port ${serverPort} is already in use. Choose another with --port.`);
          throw new Error(`Port ${serverPort} is already in use`);
        }
        await server.start(serverPort);
        console.info("Server started successfully");
      } catch (error) {
        console.error("Error starting server:", error);
        if (error instanceof Error) {
          console.error("Error details:", error.message);
          console.error("Stack trace:", error.stack);
        }
        throw error;
      }
      try {
        console.info(
          `Found ${project.agents.length} agents in ${project.isPlugin ? "plugin" : "project"}`
        );
        if (project.isPlugin || project.agents.length === 0) {
          process.env.ELIZA_TESTING_PLUGIN = "true";
          console.info("Using default Eliza character as test agent");
          try {
            const { character: defaultElizaCharacter } = await import("./eliza-B56L4TAD.js");
            const pluginsToTest = [project.pluginModule];
            console.info(`Starting test agent with plugin: ${project.pluginModule?.name}`);
            console.debug(
              `Using default character with plugins: ${defaultElizaCharacter.plugins ? defaultElizaCharacter.plugins.join(", ") : "none"}`
            );
            console.info(
              "Plugin test mode: Using default character's plugins plus the plugin being tested"
            );
            const runtime = await startAgent(
              defaultElizaCharacter,
              server,
              void 0,
              pluginsToTest,
              {
                isPluginTestMode: true
              }
            );
            runtimes.push(runtime);
            projectAgents.push({
              character: defaultElizaCharacter,
              plugins: pluginsToTest
            });
            console.info("Default test agent started successfully");
          } catch (pluginError) {
            console.error(`Error starting plugin test agent: ${pluginError}`);
            throw pluginError;
          }
        } else {
          for (const agent of project.agents) {
            try {
              const originalCharacter = { ...agent.character };
              console.debug(`Starting agent: ${originalCharacter.name}`);
              const runtime = await startAgent(
                originalCharacter,
                server,
                agent.init,
                agent.plugins || []
              );
              runtimes.push(runtime);
              projectAgents.push(agent);
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            } catch (agentError) {
              console.error(`Error starting agent ${agent.character.name}:`, agentError);
              if (agentError instanceof Error) {
                console.error("Error details:", agentError.message);
                console.error("Stack trace:", agentError.stack);
              }
              console.warn(`Skipping agent ${agent.character.name} due to startup error`);
            }
          }
        }
        if (runtimes.length === 0) {
          throw new Error("Failed to start any agents from project");
        }
        console.debug(`Successfully started ${runtimes.length} agents for testing`);
        let totalFailed = 0;
        try {
          for (let i = 0; i < runtimes.length; i++) {
            const runtime = runtimes[i];
            const projectAgent = projectAgents[i];
            if (project.isPlugin) {
              console.debug(`Running tests for plugin: ${project.pluginModule?.name}`);
            } else {
              console.debug(`Running tests for agent: ${runtime.character.name}`);
            }
            const testRunner = new TestRunner(runtime, projectAgent);
            const skipPlugins = project.isPlugin;
            const processedFilter = processFilterName(options.name);
            const results = await testRunner.runTests({
              filter: processedFilter,
              // Use processed name for filtering
              skipPlugins,
              skipProjectTests: false
            });
            totalFailed += results.failed;
          }
          return { failed: totalFailed > 0 };
        } catch (error) {
          console.error("Error running tests:", error);
          if (error instanceof Error) {
            console.error("Error details:", error.message);
            console.error("Stack trace:", error.stack);
          }
          throw error;
        } finally {
          await server.stop();
        }
      } catch (error) {
        console.error("Error in runE2eTests:", error);
        if (error instanceof Error) {
          console.error("Error details:", error.message);
          console.error("Stack trace:", error.stack);
        } else {
          console.error("Unknown error type:", typeof error);
          console.error("Error value:", error);
          try {
            console.error("Stringified error:", JSON.stringify(error, null, 2));
          } catch (e) {
            console.error("Could not stringify error:", e);
          }
        }
        return { failed: true };
      }
    } catch (error) {
      console.error("Error in runE2eTests:", error);
      if (error instanceof Error) {
        console.error("Error details:", error.message);
        console.error("Stack trace:", error.stack);
      } else {
        console.error("Unknown error type:", typeof error);
        console.error("Error value:", error);
        try {
          console.error("Stringified error:", JSON.stringify(error, null, 2));
        } catch (e) {
          console.error("Could not stringify error:", e);
        }
      }
      return { failed: true };
    }
  } catch (error) {
    console.error("Error in runE2eTests:", error);
    if (error instanceof Error) {
      console.error("Error details:", error.message);
      console.error("Stack trace:", error.stack);
    } else {
      console.error("Unknown error type:", typeof error);
      console.error("Error value:", error);
      try {
        console.error("Stringified error:", JSON.stringify(error, null, 2));
      } catch (e) {
        console.error("Could not stringify error:", e);
      }
    }
    return { failed: true };
  }
};
async function runAllTests(options) {
  const componentResult = await runComponentTests(options);
  const e2eResult = await runE2eTests({ ...options, skipBuild: true });
  return { failed: componentResult.failed || e2eResult.failed };
}
var test = new Command().name("test").description("Run tests for Eliza agent projects and plugins");
test.command("component").description("Run component tests (via Vitest)").action(async (_, cmd) => {
  const options = {
    name: cmd.parent.opts().name,
    skipBuild: cmd.parent.opts().skipBuild
  };
  console.info("Starting component tests...");
  console.info("Command options:", options);
  try {
    const result = await runComponentTests(options);
    process.exit(result.failed ? 1 : 0);
  } catch (error) {
    console.error("Error running component tests:", error);
    process.exit(1);
  }
});
test.command("e2e").description("Run end-to-end runtime tests").action(async (_, cmd) => {
  const options = {
    port: cmd.parent.opts().port,
    name: cmd.parent.opts().name,
    skipBuild: cmd.parent.opts().skipBuild
  };
  console.info("Starting e2e tests...");
  console.info("Command options:", options);
  try {
    const result = await runE2eTests(options);
    process.exit(result.failed ? 1 : 0);
  } catch (error) {
    console.error("Error running e2e tests:", error);
    process.exit(1);
  }
});
test.command("all", { isDefault: true }).description("Run both component and e2e tests (default)").action(async (_, cmd) => {
  const options = {
    port: cmd.parent.opts().port,
    name: cmd.parent.opts().name,
    skipBuild: cmd.parent.opts().skipBuild
  };
  console.info("Starting all tests...");
  console.info("Command options:", options);
  try {
    const result = await runAllTests(options);
    process.exit(result.failed ? 1 : 0);
  } catch (error) {
    console.error("Error running tests:", error);
    process.exit(1);
  }
});
test.addOption(
  new Option("-p, --port <port>", "Server port for e2e tests").argParser(
    (val) => Number.parseInt(val)
  )
).option("-n, --name <n>", "Filter tests by name (matches file names or test suite names)").option("--skip-build", "Skip building before running tests");
function registerCommand(cli) {
  return cli.addCommand(test);
}

export {
  test,
  registerCommand
};
