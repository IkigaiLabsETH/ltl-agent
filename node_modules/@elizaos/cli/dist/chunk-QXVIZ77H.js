
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  UserEnvironment,
  buildProject,
  handleError,
  isMonorepoContext
} from "./chunk-RZ4QEERU.js";
import {
  Command,
  Option
} from "./chunk-W4LNCUVN.js";

// src/commands/dev.ts
import chokidar from "chokidar";
import { spawn } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { logger } from "@elizaos/core";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
var serverProcess = null;
async function stopServer() {
  if (serverProcess) {
    console.info("Stopping current server process...");
    const killed = serverProcess.kill("SIGTERM");
    if (!killed) {
      console.warn("Failed to kill server process, trying force kill...");
      serverProcess.kill("SIGKILL");
    }
    serverProcess = null;
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
}
async function startServer(args = []) {
  await stopServer();
  console.info("Starting server...");
  console.debug("Environment:", {
    execPath: process.execPath,
    scriptPath: process.argv[1],
    cwd: process.cwd(),
    args,
    env: process.env.NODE_ENV || "development"
  });
  const nodeExecutable = process.execPath;
  const scriptPath = process.argv[1];
  serverProcess = spawn(nodeExecutable, [scriptPath, "start", ...args], {
    stdio: "inherit",
    detached: false,
    // We want to keep control of this process
    env: { ...process.env, FORCE_COLOR: "1" }
    // Ensure color output in CI
  });
  logger.debug("Started server process with:", {
    cmd: nodeExecutable,
    args: [scriptPath, "start", ...args]
  });
  serverProcess.on("exit", (code, signal) => {
    if (code !== null) {
      if (code !== 0) {
        console.warn(`Server process exited with code ${code}`);
      } else {
        console.info("Server process exited normally");
      }
    } else if (signal) {
      console.info(`Server process was killed with signal ${signal}`);
    }
    serverProcess = null;
  });
  serverProcess.on("error", (err) => {
    console.error(`Server process error: ${err.message}`);
    serverProcess = null;
  });
}
async function determineProjectType() {
  const cwd = process.cwd();
  const packageJsonPath = path.join(cwd, "package.json");
  const isMonorepo = await isMonorepoContext();
  logger.info(`Running in directory: ${cwd}`);
  logger.info(`Detected Eliza monorepo context: ${isMonorepo}`);
  let isProject = false;
  let isPlugin = false;
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
      console.info(`Package name: ${packageJson.name}`);
      console.info(
        `Package type check: ${JSON.stringify({
          "eliza.type": packageJson.eliza?.type,
          "name.includes(plugin)": packageJson.name?.includes("plugin-"),
          keywords: packageJson.keywords
        })}`
      );
      if (packageJson.name === "@elizaos/cli") {
        return { isProject: false, isPlugin: false };
      }
      if (packageJson.eliza?.type === "plugin" || packageJson.name?.includes("plugin-") || packageJson.keywords && Array.isArray(packageJson.keywords) && packageJson.keywords.some((k) => k === "elizaos-plugin" || k === "eliza-plugin")) {
        isPlugin = true;
        console.info("Identified as a plugin package");
      }
      if (packageJson.eliza?.type === "project" || packageJson.name && (packageJson.name.includes("project-") || packageJson.name.includes("-org")) || packageJson.keywords && Array.isArray(packageJson.keywords) && packageJson.keywords.some(
        (k) => k === "elizaos-project" || k === "eliza-project"
      )) {
        isProject = true;
        console.info("Identified as a project package");
      }
      if (!isProject && !isPlugin) {
        const indexPath = path.join(cwd, "src", "index.ts");
        if (fs.existsSync(indexPath)) {
          const indexContent = fs.readFileSync(indexPath, "utf-8");
          if (indexContent.includes("export const project") || indexContent.includes("export default") && indexContent.includes("Project")) {
            isProject = true;
            console.info("Identified as a project by src/index.ts export");
          }
        }
      }
    } catch (error) {
      console.warn(`Error parsing package.json: ${error}`);
    }
  }
  return { isProject, isPlugin };
}
async function watchDirectory(dir, onChange) {
  try {
    const absoluteDir = path.resolve(dir);
    console.info(`Setting up file watching for directory: ${absoluteDir}`);
    const srcDir = path.join(absoluteDir, "src");
    const dirToWatch = fs.existsSync(srcDir) ? srcDir : absoluteDir;
    console.info(`Actually watching directory: ${dirToWatch}`);
    const watchOptions = {
      ignored: ["**/node_modules/**", "**/dist/**", "**/.git/**"],
      ignoreInitial: true,
      persistent: true,
      followSymlinks: false,
      depth: 99,
      // Set high depth to ensure we catch all nested files
      usePolling: false,
      // Only use polling if necessary
      interval: 1e3
      // Poll every second
    };
    console.info("Will watch files with extensions: .ts, .js, .tsx, .jsx");
    const watcher = chokidar.watch(dirToWatch, {
      ...watchOptions
    });
    const findTsFiles = (dir2) => {
      let results = [];
      const entries = fs.readdirSync(dir2, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dir2, entry.name);
        if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules" && entry.name !== "dist") {
          results = results.concat(findTsFiles(fullPath));
        } else if (entry.isFile() && (entry.name.endsWith(".ts") || entry.name.endsWith(".js") || entry.name.endsWith(".tsx") || entry.name.endsWith(".jsx"))) {
          results.push(path.relative(dirToWatch, fullPath));
        }
      }
      return results;
    };
    const tsFiles = findTsFiles(dirToWatch);
    console.info(`Found ${tsFiles.length} TypeScript/JavaScript files in the watched directory`);
    if (tsFiles.length > 0) {
      console.info(
        `Sample files: ${tsFiles.slice(0, 3).join(", ")}${tsFiles.length > 3 ? "..." : ""}`
      );
    }
    let debounceTimer = null;
    watcher.on("ready", () => {
      const watchedPaths = watcher.getWatched();
      const pathsCount = Object.keys(watchedPaths).length;
      console.info(`Chokidar is watching ${pathsCount} directories`);
      if (pathsCount === 0) {
        console.warn("No directories are being watched! File watching may not be working.");
        console.info("Attempting to set up alternative file watching...");
        watcher.add(`${dirToWatch}/**/*.{ts,js,tsx,jsx}`);
      } else {
        console.info(
          `Top-level watched directories: ${Object.keys(watchedPaths).slice(0, 5).join(", ")}${Object.keys(watchedPaths).length > 5 ? "..." : ""}`
        );
      }
      console.log(`File watching initialized in: ${dirToWatch}`);
    });
    watcher.on("all", (event, filePath) => {
      if (!/\.(ts|js|tsx|jsx)$/.test(filePath)) {
        return;
      }
      console.info(`File event: ${event} - ${filePath}`);
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        console.info(`Triggering rebuild for file change: ${filePath}`);
        onChange();
        debounceTimer = null;
      }, 300);
    });
    watcher.on("error", (error) => {
      console.error(`Chokidar watcher error: ${error}`);
    });
    process.on("SIGINT", () => {
      watcher.close().then(() => process.exit(0));
    });
    console.log(`Watching for file changes in ${dirToWatch}`);
  } catch (error) {
    console.error(`Error setting up file watcher: ${error.message}`);
    console.error(error.stack);
  }
}
var dev = new Command().name("dev").description(
  "Start the project or plugin in development mode with auto-rebuild, detailed logging, and file change detection"
).option("-c, --configure", "Reconfigure services and AI models (skips using saved configuration)").option("-char, --character [paths...]", "Character file(s) to use - accepts paths or URLs").option("-b, --build", "Build the project before starting").addOption(
  new Option("-p, --port <port>", "Port to listen on").argParser((val) => Number.parseInt(val))
).action(async (options) => {
  try {
    const cwd = process.cwd();
    const { isProject, isPlugin } = await determineProjectType();
    const cliArgs = [];
    if (options.port) {
      cliArgs.push("--port", options.port.toString());
      console.debug(`Using port: ${options.port}`);
    }
    if (options.configure) {
      cliArgs.push("--configure");
      console.debug("Using configure option");
    }
    if (options.character) {
      if (Array.isArray(options.character)) {
        cliArgs.push("--character", ...options.character);
      } else {
        cliArgs.push("--character", options.character);
      }
      console.debug(`Using character(s): ${options.character}`);
    }
    if (options.build) {
      cliArgs.push("--build");
      console.debug("Using build option");
    }
    const rebuildAndRestart = async () => {
      try {
        await stopServer();
        console.info("Rebuilding project after file change...");
        const isMonorepo = await isMonorepoContext();
        if (isMonorepo) {
          const { monorepoRoot } = await UserEnvironment.getInstance().getPathInfo();
          if (monorepoRoot) {
            const corePackages = [
              {
                name: "core",
                path: path.join(monorepoRoot, "packages", "core"),
                isPlugin: false
              },
              {
                name: "client",
                path: path.join(monorepoRoot, "packages", "client"),
                isPlugin: false
              },
              {
                name: "plugin-bootstrap",
                path: path.join(monorepoRoot, "packages", "plugin-bootstrap"),
                isPlugin: true
              }
            ];
            console.info("Building core monorepo packages...");
            for (const pkg of corePackages) {
              try {
                console.info(`Building ${pkg.name}...`);
                await buildProject(pkg.path, pkg.isPlugin);
              } catch (buildError) {
                console.error(`Error building ${pkg.name}: ${buildError.message}`);
              }
            }
          } else {
            console.warn("Monorepo context detected, but failed to find monorepo root.");
          }
        }
        console.info(`Building current package: ${cwd}`);
        await buildProject(cwd, isPlugin);
        console.log("Rebuild successful, restarting server...");
        await startServer(cliArgs);
      } catch (error) {
        console.error(`Error during rebuild and restart: ${error.message}`);
        if (!serverProcess) {
          console.info("Attempting to restart server regardless of build failure...");
          await startServer(cliArgs);
        }
      }
    };
    if (!isProject && !isPlugin) {
      console.warn(
        "Not in a recognized project or plugin directory. Running in standalone mode."
      );
    } else {
      console.info(`Running in ${isProject ? "project" : "plugin"} mode`);
      console.info("Building project...");
      try {
        await buildProject(cwd, isPlugin);
      } catch (error) {
        console.error(`Initial build failed: ${error.message}`);
        console.info("Continuing with dev mode anyway...");
      }
    }
    await startServer(cliArgs);
    if (isProject || isPlugin) {
      await watchDirectory(cwd, rebuildAndRestart);
      console.log("Dev mode is active! The server will restart when files change.");
      console.log("Press Ctrl+C to exit");
    } else {
      console.debug("Running in standalone mode without file watching.");
    }
  } catch (error) {
    handleError(error);
  }
});

export {
  dev
};
