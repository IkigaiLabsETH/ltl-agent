import {
  PGliteClientManager,
  PostgresConnectionManager,
  __name,
  resolvePgliteDir
} from "./chunk-QOV7MUNF.js";

// src/index.ts
import { logger as logger4 } from "@elizaos/core";

// src/pglite/adapter.ts
import { logger as logger2 } from "@elizaos/core";
import { drizzle } from "drizzle-orm/pglite";

// src/base.ts
import {
  DatabaseAdapter,
  logger,
  stringToUuid
} from "@elizaos/core";
import { and, cosineDistance, count, desc, eq, gte, inArray, lte, or, sql as sql13 } from "drizzle-orm";
import { v4 } from "uuid";

// src/schema/embedding.ts
import { sql as sql5 } from "drizzle-orm";
import { check as check2, foreignKey as foreignKey2, index as index2, pgTable as pgTable5, uuid as uuid5, vector as vector2 } from "drizzle-orm/pg-core";
import { VECTOR_DIMS } from "@elizaos/core";

// src/schema/memory.ts
import { relations, sql as sql4 } from "drizzle-orm";
import {
  boolean as boolean2,
  check,
  foreignKey,
  index,
  jsonb as jsonb4,
  pgTable as pgTable4,
  text as text4,
  uuid as uuid4
} from "drizzle-orm/pg-core";

// src/schema/agent.ts
import { sql } from "drizzle-orm";
import { boolean, jsonb, pgTable, text, unique, uuid } from "drizzle-orm/pg-core";

// src/schema/types.ts
import { customType } from "drizzle-orm/pg-core";
var stringJsonb = customType({
  dataType() {
    return "jsonb";
  },
  toDriver(value) {
    return JSON.stringify(value);
  },
  fromDriver(value) {
    return JSON.stringify(value);
  }
});
var numberTimestamp = customType({
  dataType() {
    return "timestamptz";
  },
  toDriver(value) {
    return new Date(value).toISOString();
  },
  fromDriver(value) {
    return new Date(value).getTime();
  }
});

// src/schema/agent.ts
var agentTable = pgTable(
  "agents",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    enabled: boolean("enabled").default(true).notNull(),
    createdAt: numberTimestamp("createdAt").default(sql`now()`).notNull(),
    updatedAt: numberTimestamp("updatedAt").default(sql`now()`).notNull(),
    // Character
    name: text("name").notNull(),
    username: text("username"),
    system: text("system").default(""),
    bio: jsonb("bio").$type().default(sql`'[]'::jsonb`),
    messageExamples: jsonb("message_examples").$type().default(sql`'[]'::jsonb`).notNull(),
    postExamples: jsonb("post_examples").$type().default(sql`'[]'::jsonb`).notNull(),
    topics: jsonb("topics").$type().default(sql`'[]'::jsonb`).notNull(),
    adjectives: jsonb("adjectives").$type().default(sql`'[]'::jsonb`).notNull(),
    knowledge: jsonb("knowledge").$type().default(sql`'[]'::jsonb`).notNull(),
    plugins: jsonb("plugins").$type().default(sql`'[]'::jsonb`).notNull(),
    settings: jsonb("settings").$type().default(sql`'{}'::jsonb`).notNull(),
    style: jsonb("style").$type().default(sql`'{}'::jsonb`).notNull()
  },
  (table) => {
    return {
      nameUnique: unique("name_unique").on(table.name)
    };
  }
);

// src/schema/entity.ts
import { sql as sql2 } from "drizzle-orm";
import { jsonb as jsonb2, pgTable as pgTable2, text as text2, unique as unique2, uuid as uuid2 } from "drizzle-orm/pg-core";
var entityTable = pgTable2(
  "entities",
  {
    id: uuid2("id").notNull().primaryKey(),
    agentId: uuid2("agentId").notNull().references(() => agentTable.id, {
      onDelete: "cascade"
    }),
    createdAt: numberTimestamp("createdAt").default(sql2`now()`).notNull(),
    names: text2("names").array().default(sql2`'{}'::text[]`).notNull(),
    metadata: jsonb2("metadata").default(sql2`'{}'::jsonb`).notNull()
  },
  (table) => {
    return {
      idAgentIdUnique: unique2("id_agent_id_unique").on(table.id, table.agentId)
    };
  }
);

// src/schema/room.ts
import { sql as sql3 } from "drizzle-orm";
import { jsonb as jsonb3, pgTable as pgTable3, text as text3, uuid as uuid3 } from "drizzle-orm/pg-core";
var roomTable = pgTable3("rooms", {
  id: uuid3("id").notNull().primaryKey().default(sql3`gen_random_uuid()`),
  agentId: uuid3("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  source: text3("source").notNull(),
  type: text3("type").notNull(),
  serverId: text3("serverId"),
  worldId: uuid3("worldId"),
  // no guarantee that world exists, it is optional for now
  // .references(() => worldTable.id, {
  //   onDelete: 'cascade',
  // }),
  name: text3("name"),
  metadata: jsonb3("metadata"),
  channelId: text3("channelId"),
  createdAt: numberTimestamp("createdAt").default(sql3`now()`).notNull()
});

// src/schema/memory.ts
var memoryTable = pgTable4(
  "memories",
  {
    id: uuid4("id").primaryKey().notNull(),
    type: text4("type").notNull(),
    createdAt: numberTimestamp("createdAt").default(sql4`now()`).notNull(),
    content: jsonb4("content").notNull(),
    entityId: uuid4("entityId").references(() => entityTable.id, {
      onDelete: "cascade"
    }),
    agentId: uuid4("agentId").references(() => agentTable.id, {
      onDelete: "cascade"
    }).notNull(),
    roomId: uuid4("roomId").references(() => roomTable.id, {
      onDelete: "cascade"
    }),
    worldId: uuid4("worldId"),
    // .references(() => worldTable.id, {
    //   onDelete: 'set null',
    // }),
    unique: boolean2("unique").default(true).notNull(),
    metadata: jsonb4("metadata").default({}).notNull()
  },
  (table) => [
    index("idx_memories_type_room").on(table.type, table.roomId),
    index("idx_memories_world_id").on(table.worldId),
    foreignKey({
      name: "fk_room",
      columns: [table.roomId],
      foreignColumns: [roomTable.id]
    }).onDelete("cascade"),
    foreignKey({
      name: "fk_user",
      columns: [table.entityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade"),
    foreignKey({
      name: "fk_agent",
      columns: [table.agentId],
      foreignColumns: [agentTable.id]
    }).onDelete("cascade"),
    // foreignKey({
    //   name: 'fk_world',
    //   columns: [table.worldId],
    //   foreignColumns: [worldTable.id],
    // }).onDelete('set null'),
    index("idx_memories_metadata_type").on(sql4`((metadata->>'type'))`),
    index("idx_memories_document_id").on(sql4`((metadata->>'documentId'))`),
    index("idx_fragments_order").on(
      sql4`((metadata->>'documentId'))`,
      sql4`((metadata->>'position'))`
    ),
    check(
      "fragment_metadata_check",
      sql4`
            CASE 
                WHEN metadata->>'type' = 'fragment' THEN
                    metadata ? 'documentId' AND 
                    metadata ? 'position'
                ELSE true
            END
        `
    ),
    check(
      "document_metadata_check",
      sql4`
            CASE 
                WHEN metadata->>'type' = 'document' THEN
                    metadata ? 'timestamp'
                ELSE true
            END
        `
    )
  ]
);
var memoryRelations = relations(memoryTable, ({ one }) => ({
  embedding: one(embeddingTable)
}));

// src/schema/embedding.ts
var DIMENSION_MAP = {
  [VECTOR_DIMS.SMALL]: "dim384",
  [VECTOR_DIMS.MEDIUM]: "dim512",
  [VECTOR_DIMS.LARGE]: "dim768",
  [VECTOR_DIMS.XL]: "dim1024",
  [VECTOR_DIMS.XXL]: "dim1536",
  [VECTOR_DIMS.XXXL]: "dim3072"
};
var embeddingTable = pgTable5(
  "embeddings",
  {
    id: uuid5("id").primaryKey().defaultRandom().notNull(),
    memoryId: uuid5("memory_id").references(() => memoryTable.id),
    createdAt: numberTimestamp("created_at").default(sql5`now()`).notNull(),
    dim384: vector2("dim_384", { dimensions: VECTOR_DIMS.SMALL }),
    dim512: vector2("dim_512", { dimensions: VECTOR_DIMS.MEDIUM }),
    dim768: vector2("dim_768", { dimensions: VECTOR_DIMS.LARGE }),
    dim1024: vector2("dim_1024", { dimensions: VECTOR_DIMS.XL }),
    dim1536: vector2("dim_1536", { dimensions: VECTOR_DIMS.XXL }),
    dim3072: vector2("dim_3072", { dimensions: VECTOR_DIMS.XXXL })
  },
  (table) => [
    check2("embedding_source_check", sql5`"memory_id" IS NOT NULL`),
    index2("idx_embedding_memory").on(table.memoryId),
    foreignKey2({
      name: "fk_embedding_memory",
      columns: [table.memoryId],
      foreignColumns: [memoryTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/cache.ts
import { sql as sql6 } from "drizzle-orm";
import { jsonb as jsonb5, pgTable as pgTable6, text as text5, unique as unique4, uuid as uuid6 } from "drizzle-orm/pg-core";
var cacheTable = pgTable6(
  "cache",
  {
    id: uuid6("id").notNull().primaryKey().default(sql6`gen_random_uuid()`),
    key: text5("key").notNull(),
    agentId: uuid6("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
    value: jsonb5("value").notNull(),
    createdAt: numberTimestamp("createdAt").default(sql6`now()`).notNull(),
    expiresAt: numberTimestamp("expiresAt")
  },
  (table) => [unique4("cache_key_agent_unique").on(table.key, table.agentId)]
);

// src/schema/component.ts
import { sql as sql8 } from "drizzle-orm";
import { jsonb as jsonb7, pgTable as pgTable8, text as text7, uuid as uuid8 } from "drizzle-orm/pg-core";

// src/schema/world.ts
import { sql as sql7 } from "drizzle-orm";
import { jsonb as jsonb6, pgTable as pgTable7, text as text6, uuid as uuid7 } from "drizzle-orm/pg-core";
var worldTable = pgTable7("worlds", {
  id: uuid7("id").notNull().primaryKey().default(sql7`gen_random_uuid()`),
  agentId: uuid7("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  name: text6("name").notNull(),
  metadata: jsonb6("metadata"),
  serverId: text6("serverId").notNull(),
  createdAt: numberTimestamp("createdAt").default(sql7`now()`).notNull()
});

// src/schema/component.ts
var componentTable = pgTable8("components", {
  id: uuid8("id").primaryKey().defaultRandom(),
  entityId: uuid8("entityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  agentId: uuid8("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  roomId: uuid8("roomId").notNull().references(() => roomTable.id, { onDelete: "cascade" }),
  worldId: uuid8("worldId").references(() => worldTable.id, {
    onDelete: "cascade"
  }),
  sourceEntityId: uuid8("sourceEntityId").references(() => entityTable.id, {
    onDelete: "cascade"
  }),
  type: text7("type").notNull(),
  data: jsonb7("data").default(sql8`'{}'::jsonb`),
  createdAt: numberTimestamp("createdAt").default(sql8`now()`).notNull()
});

// src/schema/log.ts
import { sql as sql9 } from "drizzle-orm";
import { foreignKey as foreignKey3, jsonb as jsonb8, pgTable as pgTable9, text as text8, uuid as uuid9 } from "drizzle-orm/pg-core";
var logTable = pgTable9(
  "logs",
  {
    id: uuid9("id").defaultRandom().notNull(),
    createdAt: numberTimestamp("createdAt").default(sql9`now()`).notNull(),
    entityId: uuid9("entityId").notNull().references(() => entityTable.id),
    body: jsonb8("body").notNull(),
    type: text8("type").notNull(),
    roomId: uuid9("roomId").notNull().references(() => roomTable.id, { onDelete: "cascade" })
  },
  (table) => [
    foreignKey3({
      name: "fk_room",
      columns: [table.roomId],
      foreignColumns: [roomTable.id]
    }).onDelete("cascade"),
    foreignKey3({
      name: "fk_user",
      columns: [table.entityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/participant.ts
import { sql as sql10 } from "drizzle-orm";
import { foreignKey as foreignKey4, index as index3, pgTable as pgTable10, text as text9, uuid as uuid10 } from "drizzle-orm/pg-core";
var participantTable = pgTable10(
  "participants",
  {
    id: uuid10("id").notNull().primaryKey().default(sql10`gen_random_uuid()`),
    createdAt: numberTimestamp("createdAt").default(sql10`now()`).notNull(),
    entityId: uuid10("entityId").references(() => entityTable.id, {
      onDelete: "cascade"
    }),
    roomId: uuid10("roomId").references(() => roomTable.id, {
      onDelete: "cascade"
    }),
    agentId: uuid10("agentId").references(() => agentTable.id, {
      onDelete: "cascade"
    }),
    roomState: text9("roomState")
  },
  (table) => [
    // unique("participants_user_room_agent_unique").on(table.entityId, table.roomId, table.agentId),
    index3("idx_participants_user").on(table.entityId),
    index3("idx_participants_room").on(table.roomId),
    foreignKey4({
      name: "fk_room",
      columns: [table.roomId],
      foreignColumns: [roomTable.id]
    }).onDelete("cascade"),
    foreignKey4({
      name: "fk_user",
      columns: [table.entityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/relationship.ts
import { sql as sql11 } from "drizzle-orm";
import { foreignKey as foreignKey5, index as index4, jsonb as jsonb9, pgTable as pgTable11, text as text10, unique as unique6, uuid as uuid11 } from "drizzle-orm/pg-core";
var relationshipTable = pgTable11(
  "relationships",
  {
    id: uuid11("id").notNull().primaryKey().default(sql11`gen_random_uuid()`),
    createdAt: numberTimestamp("createdAt").default(sql11`now()`).notNull(),
    sourceEntityId: uuid11("sourceEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
    targetEntityId: uuid11("targetEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
    agentId: uuid11("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
    tags: text10("tags").array(),
    metadata: jsonb9("metadata")
  },
  (table) => [
    index4("idx_relationships_users").on(table.sourceEntityId, table.targetEntityId),
    unique6("unique_relationship").on(table.sourceEntityId, table.targetEntityId, table.agentId),
    foreignKey5({
      name: "fk_user_a",
      columns: [table.sourceEntityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade"),
    foreignKey5({
      name: "fk_user_b",
      columns: [table.targetEntityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/tasks.ts
import { jsonb as jsonb10, pgTable as pgTable12, text as text11, timestamp, uuid as uuid12 } from "drizzle-orm/pg-core";
import { sql as sql12 } from "drizzle-orm";
var taskTable = pgTable12("tasks", {
  id: uuid12("id").primaryKey().defaultRandom(),
  name: text11("name").notNull(),
  description: text11("description"),
  roomId: uuid12("roomId"),
  worldId: uuid12("worldId"),
  entityId: uuid12("entityId"),
  agentId: uuid12("agent_id").notNull(),
  tags: text11("tags").array().default(sql12`'{}'::text[]`),
  metadata: jsonb10("metadata").default(sql12`'{}'::jsonb`),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow()
});

// src/base.ts
var BaseDrizzleAdapter = class extends DatabaseAdapter {
  static {
    __name(this, "BaseDrizzleAdapter");
  }
  maxRetries = 3;
  baseDelay = 1e3;
  maxDelay = 1e4;
  jitterMax = 1e3;
  embeddingDimension = DIMENSION_MAP[384];
  agentId;
  /**
   * Constructor for creating a new instance of Agent with the specified agentId.
   *
   * @param {UUID} agentId - The unique identifier for the agent.
   */
  constructor(agentId) {
    super();
    this.agentId = agentId;
  }
  /**
   * Executes the given operation with retry logic.
   * @template T
   * @param {() => Promise<T>} operation - The operation to be executed.
   * @returns {Promise<T>} A promise that resolves with the result of the operation.
   */
  async withRetry(operation) {
    let lastError = new Error("Unknown error");
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt < this.maxRetries) {
          const backoffDelay = Math.min(this.baseDelay * 2 ** (attempt - 1), this.maxDelay);
          const jitter = Math.random() * this.jitterMax;
          const delay = backoffDelay + jitter;
          logger.warn(`Database operation failed (attempt ${attempt}/${this.maxRetries}):`, {
            error: error instanceof Error ? error.message : String(error),
            nextRetryIn: `${(delay / 1e3).toFixed(1)}s`
          });
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          logger.error("Max retry attempts reached:", {
            error: error instanceof Error ? error.message : String(error),
            totalAttempts: attempt
          });
          throw error instanceof Error ? error : new Error(String(error));
        }
      }
    }
    throw lastError;
  }
  /**
   * Asynchronously ensures that an agent exists by checking if an agent with the same name already exists in the system.
   * If the agent does not exist, it will be created with the provided data.
   *
   * @param {Partial<Agent>} agent - The partial data of the agent to ensure its existence.
   * @returns {Promise<void>} - A promise that resolves when the agent is successfully ensured.
   * @throws {Error} - If the agent name is not provided or if there is an issue creating the agent.
   */
  async ensureAgentExists(agent) {
    if (!agent.name) {
      throw new Error("Agent name is required");
    }
    const agents = await this.getAgents();
    const existingAgentId = agents.find((a) => a.name === agent.name)?.id;
    if (existingAgentId) {
      const existingAgent = await this.getAgent(existingAgentId);
      return existingAgent;
    }
    const newAgent = {
      ...agent,
      id: stringToUuid(agent.name)
    };
    await this.createAgent(newAgent);
    return newAgent;
  }
  /**
   * Asynchronously ensures that the given embedding dimension is valid for the agent.
   *
   * @param {number} dimension - The dimension to ensure for the embedding.
   * @returns {Promise<void>} - Resolves once the embedding dimension is ensured.
   */
  async ensureEmbeddingDimension(dimension) {
    return this.withDatabase(async () => {
      const existingMemory = await this.db.select({
        embedding: embeddingTable
      }).from(memoryTable).innerJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(eq(memoryTable.agentId, this.agentId)).limit(1);
      if (existingMemory.length > 0) {
        const usedDimension = Object.entries(DIMENSION_MAP).find(
          ([_, colName]) => existingMemory[0].embedding[colName] !== null
        );
      }
      this.embeddingDimension = DIMENSION_MAP[dimension];
    });
  }
  /**
   * Asynchronously retrieves an agent by their ID from the database.
   * @param {UUID} agentId - The ID of the agent to retrieve.
   * @returns {Promise<Agent | null>} A promise that resolves to the retrieved agent or null if not found.
   */
  async getAgent(agentId) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
      if (rows.length === 0) return null;
      const row = rows[0];
      return {
        ...row,
        username: row.username || "",
        id: row.id,
        system: !row.system ? void 0 : row.system,
        bio: !row.bio ? "" : row.bio
      };
    });
  }
  /**
   * Asynchronously retrieves a list of agents from the database.
   *
   * @returns {Promise<Partial<Agent>[]>} A Promise that resolves to an array of Agent objects.
   */
  async getAgents() {
    return this.withDatabase(async () => {
      const rows = await this.db.select({
        id: agentTable.id,
        name: agentTable.name,
        bio: agentTable.bio
      }).from(agentTable);
      return rows.map((row) => ({
        ...row,
        id: row.id,
        bio: row.bio === null ? "" : row.bio
      }));
    });
  }
  /**
   * Asynchronously creates a new agent record in the database.
   *
   * @param {Partial<Agent>} agent The agent object to be created.
   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating the success of the operation.
   */
  async createAgent(agent) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.insert(agentTable).values({
            ...agent
          });
        });
        logger.debug("Agent created successfully:", {
          agentId: agent.id
        });
        return true;
      } catch (error) {
        logger.error("Error creating agent:", {
          error: error instanceof Error ? error.message : String(error),
          agentId: agent.id,
          agent
        });
        return false;
      }
    });
  }
  /**
   * Updates an agent in the database with the provided agent ID and data.
   * @param {UUID} agentId - The unique identifier of the agent to update.
   * @param {Partial<Agent>} agent - The partial agent object containing the fields to update.
   * @returns {Promise<boolean>} - A boolean indicating if the agent was successfully updated.
   */
  async updateAgent(agentId, agent) {
    return this.withDatabase(async () => {
      try {
        if (!agentId) {
          throw new Error("Agent ID is required for update");
        }
        await this.db.transaction(async (tx) => {
          if (agent?.settings) {
            agent.settings = await this.mergeAgentSettings(tx, agentId, agent.settings);
          }
          await tx.update(agentTable).set({
            ...agent,
            updatedAt: Date.now()
          }).where(eq(agentTable.id, agentId));
        });
        logger.debug("Agent updated successfully:", {
          agentId
        });
        return true;
      } catch (error) {
        logger.error("Error updating agent:", {
          error: error instanceof Error ? error.message : String(error),
          agentId,
          agent
        });
        return false;
      }
    });
  }
  /**
   * Merges updated agent settings with existing settings in the database,
   * with special handling for nested objects like secrets.
   * @param tx - The database transaction
   * @param agentId - The ID of the agent
   * @param updatedSettings - The settings object with updates
   * @returns The merged settings object
   * @private
   */
  async mergeAgentSettings(tx, agentId, updatedSettings) {
    const currentAgent = await tx.select({ settings: agentTable.settings }).from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
    const currentSettings = currentAgent.length > 0 && currentAgent[0].settings ? currentAgent[0].settings : {};
    const deepMerge = /* @__PURE__ */ __name((target, source) => {
      if (source === null) {
        return void 0;
      }
      if (Array.isArray(source) || typeof source !== "object") {
        return source;
      }
      const output = typeof target === "object" && target !== null && !Array.isArray(target) ? { ...target } : {};
      let isEmpty = true;
      for (const key of Object.keys(source)) {
        const sourceValue = source[key];
        if (sourceValue === null) {
          delete output[key];
        } else if (typeof sourceValue === "object" && !Array.isArray(sourceValue)) {
          const nestedMergeResult = deepMerge(output[key], sourceValue);
          if (nestedMergeResult === void 0) {
            delete output[key];
          } else {
            output[key] = nestedMergeResult;
            isEmpty = false;
          }
        } else {
          output[key] = sourceValue;
          isEmpty = false;
        }
      }
      if (Object.keys(output).length === 0) {
        if (!(typeof source === "object" && source !== null && Object.keys(source).length === 0)) {
          return void 0;
        }
      }
      return output;
    }, "deepMerge");
    const finalSettings = deepMerge(currentSettings, updatedSettings);
    return finalSettings === void 0 ? {} : finalSettings;
  }
  /**
   * Asynchronously deletes an agent with the specified UUID and all related entries.
   *
   * @param {UUID} agentId - The UUID of the agent to be deleted.
   * @returns {Promise<boolean>} - A boolean indicating if the deletion was successful.
   */
  async deleteAgent(agentId) {
    logger.debug(`[DB] Starting deletion of agent with ID: ${agentId}`);
    return this.withDatabase(async () => {
      try {
        logger.debug(`[DB] Beginning database transaction for deleting agent: ${agentId}`);
        const deletePromise = new Promise((resolve, reject) => {
          const timeoutId = setTimeout(() => {
            logger.error(`[DB] Transaction timeout reached for agent deletion: ${agentId}`);
            reject(new Error("Database transaction timeout"));
          }, 3e4);
          this.db.transaction(async (tx) => {
            try {
              logger.debug(`[DB] Fetching entities for agent: ${agentId}`);
              const entities = await tx.select({ entityId: entityTable.id }).from(entityTable).where(eq(entityTable.agentId, agentId));
              const entityIds = entities.map((e) => e.entityId);
              logger.debug(
                `[DB] Found ${entityIds.length} entities to delete for agent ${agentId}`
              );
              logger.debug(`[DB] Fetching rooms for agent: ${agentId}`);
              const rooms = await tx.select({ roomId: roomTable.id }).from(roomTable).where(eq(roomTable.agentId, agentId));
              const roomIds = rooms.map((r) => r.roomId);
              logger.debug(`[DB] Found ${roomIds.length} rooms for agent ${agentId}`);
              logger.debug(
                `[DB] Explicitly deleting ALL logs with matching entityIds and roomIds`
              );
              if (entityIds.length > 0) {
                logger.debug(`[DB] Deleting logs for ${entityIds.length} entities (first batch)`);
                const BATCH_SIZE = 50;
                for (let i = 0; i < entityIds.length; i += BATCH_SIZE) {
                  const batch = entityIds.slice(i, i + BATCH_SIZE);
                  logger.debug(
                    `[DB] Processing entity logs batch ${i / BATCH_SIZE + 1} with ${batch.length} entities`
                  );
                  await tx.delete(logTable).where(inArray(logTable.entityId, batch));
                }
                logger.debug(`[DB] Entity logs deletion completed successfully`);
              }
              if (roomIds.length > 0) {
                logger.debug(`[DB] Deleting logs for ${roomIds.length} rooms (first batch)`);
                const BATCH_SIZE = 50;
                for (let i = 0; i < roomIds.length; i += BATCH_SIZE) {
                  const batch = roomIds.slice(i, i + BATCH_SIZE);
                  logger.debug(
                    `[DB] Processing room logs batch ${i / BATCH_SIZE + 1} with ${batch.length} rooms`
                  );
                  await tx.delete(logTable).where(inArray(logTable.roomId, batch));
                }
                logger.debug(`[DB] Room logs deletion completed successfully`);
              }
              let memoryIds = [];
              if (entityIds.length > 0) {
                logger.debug(`[DB] Finding memories belonging to entities`);
                const memories = await tx.select({ id: memoryTable.id }).from(memoryTable).where(inArray(memoryTable.entityId, entityIds));
                memoryIds = memories.map((m) => m.id);
                logger.debug(`[DB] Found ${memoryIds.length} memories belonging to entities`);
              }
              logger.debug(`[DB] Finding memories belonging to agent directly`);
              const agentMemories = await tx.select({ id: memoryTable.id }).from(memoryTable).where(eq(memoryTable.agentId, agentId));
              memoryIds = [...memoryIds, ...agentMemories.map((m) => m.id)];
              logger.debug(`[DB] Found total of ${memoryIds.length} memories to delete`);
              if (roomIds.length > 0) {
                logger.debug(`[DB] Finding memories belonging to rooms`);
                const roomMemories = await tx.select({ id: memoryTable.id }).from(memoryTable).where(inArray(memoryTable.roomId, roomIds));
                memoryIds = [...memoryIds, ...roomMemories.map((m) => m.id)];
                logger.debug(`[DB] Updated total to ${memoryIds.length} memories to delete`);
              }
              if (memoryIds.length > 0) {
                logger.debug(`[DB] Deleting embeddings for ${memoryIds.length} memories`);
                const BATCH_SIZE = 100;
                for (let i = 0; i < memoryIds.length; i += BATCH_SIZE) {
                  const batch = memoryIds.slice(i, i + BATCH_SIZE);
                  await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, batch));
                }
                logger.debug(`[DB] Embeddings deleted successfully`);
              }
              if (memoryIds.length > 0) {
                logger.debug(`[DB] Deleting ${memoryIds.length} memories`);
                const BATCH_SIZE = 100;
                for (let i = 0; i < memoryIds.length; i += BATCH_SIZE) {
                  const batch = memoryIds.slice(i, i + BATCH_SIZE);
                  await tx.delete(memoryTable).where(inArray(memoryTable.id, batch));
                }
                logger.debug(`[DB] Memories deleted successfully`);
              }
              if (entityIds.length > 0) {
                logger.debug(`[DB] Deleting components for entities`);
                await tx.delete(componentTable).where(inArray(componentTable.entityId, entityIds));
                logger.debug(`[DB] Components deleted successfully`);
              }
              if (entityIds.length > 0) {
                logger.debug(`[DB] Deleting source entity references in components`);
                await tx.delete(componentTable).where(inArray(componentTable.sourceEntityId, entityIds));
                logger.debug(`[DB] Source entity references deleted successfully`);
              }
              if (roomIds.length > 0) {
                logger.debug(`[DB] Deleting participations for rooms`);
                await tx.delete(participantTable).where(inArray(participantTable.roomId, roomIds));
                logger.debug(`[DB] Participations deleted for rooms`);
              }
              logger.debug(`[DB] Deleting agent participations`);
              await tx.delete(participantTable).where(eq(participantTable.agentId, agentId));
              logger.debug(`[DB] Agent participations deleted`);
              if (roomIds.length > 0) {
                logger.debug(`[DB] Deleting rooms`);
                await tx.delete(roomTable).where(inArray(roomTable.id, roomIds));
                logger.debug(`[DB] Rooms deleted successfully`);
              }
              logger.debug(`[DB] Deleting cache entries`);
              await tx.delete(cacheTable).where(eq(cacheTable.agentId, agentId));
              logger.debug(`[DB] Cache entries deleted successfully`);
              logger.debug(`[DB] Deleting relationships`);
              if (entityIds.length > 0) {
                await tx.delete(relationshipTable).where(inArray(relationshipTable.sourceEntityId, entityIds));
                await tx.delete(relationshipTable).where(inArray(relationshipTable.targetEntityId, entityIds));
              }
              await tx.delete(relationshipTable).where(eq(relationshipTable.agentId, agentId));
              logger.debug(`[DB] Relationships deleted successfully`);
              if (entityIds.length > 0) {
                logger.debug(`[DB] Deleting entities`);
                await tx.delete(entityTable).where(eq(entityTable.agentId, agentId));
                logger.debug(`[DB] Entities deleted successfully`);
              }
              logger.debug(`[DB] Checking for world references`);
              const worlds = await tx.select({ id: worldTable.id }).from(worldTable).where(eq(worldTable.agentId, agentId));
              if (worlds.length > 0) {
                const worldIds = worlds.map((w) => w.id);
                logger.debug(`[DB] Found ${worldIds.length} worlds to delete`);
                await tx.delete(worldTable).where(inArray(worldTable.id, worldIds));
                logger.debug(`[DB] Worlds deleted successfully`);
              } else {
                logger.debug(`[DB] No worlds found for this agent`);
              }
              logger.debug(`[DB] Deleting agent ${agentId}`);
              await tx.delete(agentTable).where(eq(agentTable.id, agentId));
              logger.debug(`[DB] Agent deleted successfully`);
              resolve(true);
            } catch (error) {
              logger.error(`[DB] Error in transaction:`, error);
              reject(error);
            }
          }).catch((transactionError) => {
            clearTimeout(timeoutId);
            reject(transactionError);
          });
        });
        await deletePromise;
        logger.success(`[DB] Agent ${agentId} successfully deleted`);
        return true;
      } catch (error) {
        logger.error(`[DB] Error in database transaction for agent deletion ${agentId}:`, error);
        if (error instanceof Error) {
          logger.error(`[DB] Error name: ${error.name}, message: ${error.message}`);
          logger.error(`[DB] Error stack: ${error.stack}`);
        }
        throw error;
      }
    });
  }
  /**
   * Count all agents in the database
   * Used primarily for maintenance and cleanup operations
   */
  /**
   * Asynchronously counts the number of agents in the database.
   * @returns {Promise<number>} A Promise that resolves to the number of agents in the database.
   */
  async countAgents() {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ count: count() }).from(agentTable);
        return result[0]?.count || 0;
      } catch (error) {
        logger.error("Error counting agents:", {
          error: error instanceof Error ? error.message : String(error)
        });
        return 0;
      }
    });
  }
  /**
   * Clean up the agents table by removing all agents
   * This is used during server startup to ensure no orphaned agents exist
   * from previous crashes or improper shutdowns
   */
  async cleanupAgents() {
    return this.withDatabase(async () => {
      try {
        await this.db.delete(agentTable);
        logger.success("Successfully cleaned up agent table");
      } catch (error) {
        logger.error("Error cleaning up agent table:", {
          error: error instanceof Error ? error.message : String(error)
        });
        throw error;
      }
    });
  }
  /**
   * Asynchronously retrieves an entity and its components by entity IDs.
   * @param {UUID[]} entityIds - The unique identifiers of the entities to retrieve.
   * @returns {Promise<Entity[] | null>} A Promise that resolves to the entity with its components if found, null otherwise.
   */
  async getEntityByIds(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        entity: entityTable,
        components: componentTable
      }).from(entityTable).leftJoin(componentTable, eq(componentTable.entityId, entityTable.id)).where(inArray(entityTable.id, entityIds));
      if (result.length === 0) return null;
      const entities = {};
      const entityComponents = {};
      for (const e of result) {
        const key = e.entity.id;
        entities[key] = e.entity;
        if (entityComponents[key] === void 0) entityComponents[key] = [];
        if (e.components) {
          const componentsArray = Array.isArray(e.components) ? e.components : [e.components];
          entityComponents[key] = [...entityComponents[key], ...componentsArray];
        }
      }
      for (const k of Object.keys(entityComponents)) {
        entities[k].components = entityComponents[k];
      }
      return Object.values(entities);
    });
  }
  /**
   * Asynchronously retrieves all entities for a given room, optionally including their components.
   * @param {UUID} roomId - The unique identifier of the room to get entities for
   * @param {boolean} [includeComponents] - Whether to include component data for each entity
   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities in the room
   */
  async getEntitiesForRoom(roomId, includeComponents) {
    return this.withDatabase(async () => {
      const query = this.db.select({
        entity: entityTable,
        ...includeComponents && { components: componentTable }
      }).from(participantTable).leftJoin(
        entityTable,
        and(eq(participantTable.entityId, entityTable.id), eq(entityTable.agentId, this.agentId))
      );
      if (includeComponents) {
        query.leftJoin(componentTable, eq(componentTable.entityId, entityTable.id));
      }
      const result = await query.where(eq(participantTable.roomId, roomId));
      const entitiesByIdMap = /* @__PURE__ */ new Map();
      for (const row of result) {
        if (!row.entity) continue;
        const entityId = row.entity.id;
        if (!entitiesByIdMap.has(entityId)) {
          const entity = {
            ...row.entity,
            id: entityId,
            agentId: row.entity.agentId,
            metadata: row.entity.metadata,
            components: includeComponents ? [] : void 0
          };
          entitiesByIdMap.set(entityId, entity);
        }
        if (includeComponents && row.components) {
          const entity = entitiesByIdMap.get(entityId);
          if (entity) {
            if (!entity.components) {
              entity.components = [];
            }
            entity.components.push(row.components);
          }
        }
      }
      return Array.from(entitiesByIdMap.values());
    });
  }
  /**
   * Asynchronously creates new entities in the database.
   * @param {Entity[]} entities - The entity objects to be created.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.
   */
  async createEntities(entities) {
    return this.withDatabase(async () => {
      try {
        return await this.db.transaction(async (tx) => {
          await tx.insert(entityTable).values(entities);
          logger.debug(entities.length, "Entities created successfully");
          return true;
        });
      } catch (error) {
        logger.error("Error creating entity:", {
          error: error instanceof Error ? error.message : String(error),
          entityId: entities[0].id,
          name: entities[0].metadata?.name
        });
        logger.trace(error);
        return false;
      }
    });
  }
  /**
   * Asynchronously ensures an entity exists, creating it if it doesn't
   * @param entity The entity to ensure exists
   * @returns Promise resolving to boolean indicating success
   */
  async ensureEntityExists(entity) {
    if (!entity.id) {
      logger.error("Entity ID is required for ensureEntityExists");
      return false;
    }
    try {
      const existingEntities = await this.getEntityByIds([entity.id]);
      if (!existingEntities || !existingEntities.length) {
        return await this.createEntities([entity]);
      }
      return true;
    } catch (error) {
      logger.error("Error ensuring entity exists:", {
        error: error instanceof Error ? error.message : String(error),
        entityId: entity.id
      });
      return false;
    }
  }
  /**
   * Asynchronously updates an entity in the database.
   * @param {Entity} entity - The entity object to be updated.
   * @returns {Promise<void>} A Promise that resolves when the entity is updated.
   */
  async updateEntity(entity) {
    return this.withDatabase(async () => {
      await this.db.update(entityTable).set(entity).where(and(eq(entityTable.id, entity.id), eq(entityTable.agentId, entity.agentId)));
    });
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId), eq(componentTable.type, type)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select().from(componentTable).where(and(...conditions));
      if (result.length === 0) return null;
      const component = result[0];
      return {
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data
      };
    });
  }
  /**
   * Asynchronously retrieves all components for a given entity, optionally filtered by world and source entity.
   * @param {UUID} entityId - The unique identifier of the entity to retrieve components for
   * @param {UUID} [worldId] - Optional world ID to filter components by
   * @param {UUID} [sourceEntityId] - Optional source entity ID to filter components by
   * @returns {Promise<Component[]>} A Promise that resolves to an array of components
   */
  async getComponents(entityId, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select({
        id: componentTable.id,
        entityId: componentTable.entityId,
        type: componentTable.type,
        data: componentTable.data,
        worldId: componentTable.worldId,
        agentId: componentTable.agentId,
        roomId: componentTable.roomId,
        sourceEntityId: componentTable.sourceEntityId,
        createdAt: componentTable.createdAt
      }).from(componentTable).where(and(...conditions));
      if (result.length === 0) return [];
      const components = result.map((component) => ({
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data
      }));
      return components;
    });
  }
  /**
   * Asynchronously creates a new component in the database.
   * @param {Component} component - The component object to be created.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.
   */
  async createComponent(component) {
    return this.withDatabase(async () => {
      await this.db.insert(componentTable).values(component);
      return true;
    });
  }
  /**
   * Asynchronously updates an existing component in the database.
   * @param {Component} component - The component object to be updated.
   * @returns {Promise<void>} A Promise that resolves when the component is updated.
   */
  async updateComponent(component) {
    return this.withDatabase(async () => {
      await this.db.update(componentTable).set(component).where(eq(componentTable.id, component.id));
    });
  }
  /**
   * Asynchronously deletes a component from the database.
   * @param {UUID} componentId - The unique identifier of the component to delete.
   * @returns {Promise<void>} A Promise that resolves when the component is deleted.
   */
  async deleteComponent(componentId) {
    return this.withDatabase(async () => {
      await this.db.delete(componentTable).where(eq(componentTable.id, componentId));
    });
  }
  /**
   * Asynchronously retrieves memories from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving memories.
   * @param {UUID} params.roomId - The ID of the room to retrieve memories for.
   * @param {number} [params.count] - The maximum number of memories to retrieve.
   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.
   * @param {string} [params.tableName] - The name of the table to retrieve memories from.
   * @param {number} [params.start] - The start date to retrieve memories from.
   * @param {number} [params.end] - The end date to retrieve memories from.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async getMemories(params) {
    const { entityId, agentId, roomId, worldId, tableName, count: count2, unique: unique7, start, end } = params;
    if (!tableName) throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.type, tableName)];
      if (start) {
        conditions.push(gte(memoryTable.createdAt, start));
      }
      if (entityId) {
        conditions.push(eq(memoryTable.entityId, entityId));
      }
      if (roomId) {
        conditions.push(eq(memoryTable.roomId, roomId));
      }
      if (worldId) {
        conditions.push(eq(memoryTable.worldId, worldId));
      }
      if (end) {
        conditions.push(lte(memoryTable.createdAt, end));
      }
      if (unique7) {
        conditions.push(eq(memoryTable.unique, true));
      }
      if (agentId) {
        conditions.push(eq(memoryTable.agentId, agentId));
      }
      const query = this.db.select({
        memory: {
          id: memoryTable.id,
          type: memoryTable.type,
          createdAt: memoryTable.createdAt,
          content: memoryTable.content,
          entityId: memoryTable.entityId,
          agentId: memoryTable.agentId,
          roomId: memoryTable.roomId,
          unique: memoryTable.unique,
          metadata: memoryTable.metadata
        },
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.count ? await query.limit(params.count) : await query;
      return rows.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt,
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ? Array.from(row.embedding) : void 0
      }));
    });
  }
  /**
   * Asynchronously retrieves memories from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving memories.
   * @param {UUID[]} params.roomIds - The IDs of the rooms to retrieve memories for.
   * @param {string} params.tableName - The name of the table to retrieve memories from.
   * @param {number} [params.limit] - The maximum number of memories to retrieve.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async getMemoriesByRoomIds(params) {
    return this.withDatabase(async () => {
      if (params.roomIds.length === 0) return [];
      const conditions = [
        eq(memoryTable.type, params.tableName),
        inArray(memoryTable.roomId, params.roomIds)
      ];
      conditions.push(eq(memoryTable.agentId, this.agentId));
      const query = this.db.select({
        id: memoryTable.id,
        type: memoryTable.type,
        createdAt: memoryTable.createdAt,
        content: memoryTable.content,
        entityId: memoryTable.entityId,
        agentId: memoryTable.agentId,
        roomId: memoryTable.roomId,
        unique: memoryTable.unique,
        metadata: memoryTable.metadata
      }).from(memoryTable).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.limit ? await query.limit(params.limit) : await query;
      return rows.map((row) => ({
        id: row.id,
        createdAt: row.createdAt,
        content: typeof row.content === "string" ? JSON.parse(row.content) : row.content,
        entityId: row.entityId,
        agentId: row.agentId,
        roomId: row.roomId,
        unique: row.unique,
        metadata: row.metadata
      }));
    });
  }
  /**
   * Asynchronously retrieves a memory by its unique identifier.
   * @param {UUID} id - The unique identifier of the memory to retrieve.
   * @returns {Promise<Memory | null>} A Promise that resolves to the memory if found, null otherwise.
   */
  async getMemoryById(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(memoryTable.id, embeddingTable.memoryId)).where(eq(memoryTable.id, id)).limit(1);
      if (result.length === 0) return null;
      const row = result[0];
      return {
        id: row.memory.id,
        createdAt: row.memory.createdAt,
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? void 0
      };
    });
  }
  /**
   * Asynchronously retrieves memories from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving memories.
   * @param {UUID[]} params.memoryIds - The IDs of the memories to retrieve.
   * @param {string} [params.tableName] - The name of the table to retrieve memories from.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async getMemoriesByIds(memoryIds, tableName) {
    return this.withDatabase(async () => {
      if (memoryIds.length === 0) return [];
      const conditions = [inArray(memoryTable.id, memoryIds)];
      if (tableName) {
        conditions.push(eq(memoryTable.type, tableName));
      }
      const rows = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      return rows.map((row) => ({
        id: row.memory.id,
        createdAt: row.memory.createdAt,
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? void 0
      }));
    });
  }
  /**
   * Asynchronously retrieves cached embeddings from the database based on the provided parameters.
   * @param {Object} opts - The parameters for retrieving cached embeddings.
   * @param {string} opts.query_table_name - The name of the table to retrieve embeddings from.
   * @param {number} opts.query_threshold - The threshold for the levenshtein distance.
   * @param {string} opts.query_input - The input string to search for.
   * @param {string} opts.query_field_name - The name of the field to retrieve embeddings from.
   * @param {string} opts.query_field_sub_name - The name of the sub-field to retrieve embeddings from.
   * @param {number} opts.query_match_count - The maximum number of matches to retrieve.
   * @returns {Promise<{ embedding: number[]; levenshtein_score: number }[]>} A Promise that resolves to an array of cached embeddings.
   */
  async getCachedEmbeddings(opts) {
    return this.withDatabase(async () => {
      try {
        const results = await this.db.execute(sql13`
                    WITH content_text AS (
                        SELECT
                            m.id,
                            COALESCE(
                                m.content->>${opts.query_field_sub_name},
                                ''
                            ) as content_text
                        FROM memories m
                        WHERE m.type = ${opts.query_table_name}
                            AND m.content->>${opts.query_field_sub_name} IS NOT NULL
                    ),
                    embedded_text AS (
                        SELECT
                            ct.content_text,
                            COALESCE(
                                e.dim_384,
                                e.dim_512,
                                e.dim_768,
                                e.dim_1024,
                                e.dim_1536,
                                e.dim_3072
                            ) as embedding
                        FROM content_text ct
                        LEFT JOIN embeddings e ON e.memory_id = ct.id
                        WHERE e.memory_id IS NOT NULL
                    )
                    SELECT
                        embedding,
                        levenshtein(${opts.query_input}, content_text) as levenshtein_score
                    FROM embedded_text
                    WHERE levenshtein(${opts.query_input}, content_text) <= ${opts.query_threshold}
                    ORDER BY levenshtein_score
                    LIMIT ${opts.query_match_count}
                `);
        return results.rows.map((row) => ({
          embedding: Array.isArray(row.embedding) ? row.embedding : typeof row.embedding === "string" ? JSON.parse(row.embedding) : [],
          levenshtein_score: Number(row.levenshtein_score)
        })).filter((row) => Array.isArray(row.embedding));
      } catch (error) {
        logger.error("Error in getCachedEmbeddings:", {
          error: error instanceof Error ? error.message : String(error),
          tableName: opts.query_table_name,
          fieldName: opts.query_field_name
        });
        if (error instanceof Error && error.message === "levenshtein argument exceeds maximum length of 255 characters") {
          return [];
        }
        throw error;
      }
    });
  }
  /**
   * Asynchronously logs an event in the database.
   * @param {Object} params - The parameters for logging an event.
   * @param {Object} params.body - The body of the event to log.
   * @param {UUID} params.entityId - The ID of the entity associated with the event.
   * @param {UUID} params.roomId - The ID of the room associated with the event.
   * @param {string} params.type - The type of the event to log.
   * @returns {Promise<void>} A Promise that resolves when the event is logged.
   */
  async log(params) {
    return this.withDatabase(async () => {
      try {
        const sanitizedBody = this.sanitizeJsonObject(params.body);
        const jsonString = JSON.stringify(sanitizedBody);
        await this.db.transaction(async (tx) => {
          await tx.insert(logTable).values({
            body: sql13`${jsonString}::jsonb`,
            entityId: params.entityId,
            roomId: params.roomId,
            type: params.type
          });
        });
      } catch (error) {
        logger.error("Failed to create log entry:", {
          error: error instanceof Error ? error.message : String(error),
          type: params.type,
          roomId: params.roomId,
          entityId: params.entityId
        });
        throw error;
      }
    });
  }
  /**
   * Sanitizes a JSON object by replacing problematic Unicode escape sequences
   * that could cause errors during JSON serialization/storage
   *
   * @param value - The value to sanitize
   * @returns The sanitized value
   */
  sanitizeJsonObject(value) {
    if (value === null || value === void 0) {
      return value;
    }
    if (typeof value === "string") {
      return value.replace(/\u0000/g, "").replace(/\\(?!["\\/bfnrtu])/g, "\\\\").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u");
    }
    if (typeof value === "object") {
      if (Array.isArray(value)) {
        return value.map((item) => this.sanitizeJsonObject(item));
      } else {
        const result = {};
        for (const [key, val] of Object.entries(value)) {
          const sanitizedKey = typeof key === "string" ? key.replace(/\u0000/g, "").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u") : key;
          result[sanitizedKey] = this.sanitizeJsonObject(val);
        }
        return result;
      }
    }
    return value;
  }
  /**
   * Asynchronously retrieves logs from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving logs.
   * @param {UUID} params.entityId - The ID of the entity associated with the logs.
   * @param {UUID} [params.roomId] - The ID of the room associated with the logs.
   * @param {string} [params.type] - The type of the logs to retrieve.
   * @param {number} [params.count] - The maximum number of logs to retrieve.
   * @param {number} [params.offset] - The offset to retrieve logs from.
   * @returns {Promise<Log[]>} A Promise that resolves to an array of logs.
   */
  async getLogs(params) {
    const { entityId, roomId, type, count: count2, offset } = params;
    return this.withDatabase(async () => {
      const result = await this.db.select().from(logTable).where(
        and(
          eq(logTable.entityId, entityId),
          roomId ? eq(logTable.roomId, roomId) : void 0,
          type ? eq(logTable.type, type) : void 0
        )
      ).orderBy(desc(logTable.createdAt)).limit(count2 ?? 10).offset(offset ?? 0);
      const logs = result.map((log) => ({
        ...log,
        id: log.id,
        entityId: log.entityId,
        roomId: log.roomId,
        body: log.body,
        createdAt: new Date(log.createdAt)
      }));
      if (logs.length === 0) return [];
      return logs;
    });
  }
  /**
   * Asynchronously deletes a log from the database based on the provided parameters.
   * @param {UUID} logId - The ID of the log to delete.
   * @returns {Promise<void>} A Promise that resolves when the log is deleted.
   */
  async deleteLog(logId) {
    return this.withDatabase(async () => {
      await this.db.delete(logTable).where(eq(logTable.id, logId));
    });
  }
  /**
   * Asynchronously searches for memories in the database based on the provided parameters.
   * @param {Object} params - The parameters for searching for memories.
   * @param {string} params.tableName - The name of the table to search for memories in.
   * @param {number[]} params.embedding - The embedding to search for.
   * @param {number} [params.match_threshold] - The threshold for the cosine distance.
   * @param {number} [params.count] - The maximum number of memories to retrieve.
   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.
   * @param {string} [params.query] - Optional query string for potential reranking.
   * @param {UUID} [params.roomId] - Optional room ID to filter by.
   * @param {UUID} [params.worldId] - Optional world ID to filter by.
   * @param {UUID} [params.entityId] - Optional entity ID to filter by.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async searchMemories(params) {
    return await this.searchMemoriesByEmbedding(params.embedding, {
      match_threshold: params.match_threshold,
      count: params.count,
      // Pass direct scope fields down
      roomId: params.roomId,
      worldId: params.worldId,
      entityId: params.entityId,
      unique: params.unique,
      tableName: params.tableName
    });
  }
  /**
   * Asynchronously searches for memories in the database based on the provided parameters.
   * @param {number[]} embedding - The embedding to search for.
   * @param {Object} params - The parameters for searching for memories.
   * @param {number} [params.match_threshold] - The threshold for the cosine distance.
   * @param {number} [params.count] - The maximum number of memories to retrieve.
   * @param {UUID} [params.roomId] - Optional room ID to filter by.
   * @param {UUID} [params.worldId] - Optional world ID to filter by.
   * @param {UUID} [params.entityId] - Optional entity ID to filter by.
   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.
   * @param {string} [params.tableName] - The name of the table to search for memories in.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async searchMemoriesByEmbedding(embedding, params) {
    return this.withDatabase(async () => {
      const cleanVector = embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
      const similarity = sql13`1 - (${cosineDistance(
        embeddingTable[this.embeddingDimension],
        cleanVector
      )})`;
      const conditions = [eq(memoryTable.type, params.tableName)];
      if (params.unique) {
        conditions.push(eq(memoryTable.unique, true));
      }
      conditions.push(eq(memoryTable.agentId, this.agentId));
      if (params.roomId) {
        conditions.push(eq(memoryTable.roomId, params.roomId));
      }
      if (params.worldId) {
        conditions.push(eq(memoryTable.worldId, params.worldId));
      }
      if (params.entityId) {
        conditions.push(eq(memoryTable.entityId, params.entityId));
      }
      if (params.match_threshold) {
        conditions.push(gte(similarity, params.match_threshold));
      }
      const results = await this.db.select({
        memory: memoryTable,
        similarity,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(embeddingTable).innerJoin(memoryTable, eq(memoryTable.id, embeddingTable.memoryId)).where(and(...conditions)).orderBy(desc(similarity)).limit(params.count ?? 10);
      return results.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt,
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        worldId: row.memory.worldId,
        // Include worldId
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? void 0,
        similarity: row.similarity
      }));
    });
  }
  /**
   * Asynchronously creates a new memory in the database.
   * @param {Memory & { metadata?: MemoryMetadata }} memory - The memory object to create.
   * @param {string} tableName - The name of the table to create the memory in.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created memory.
   */
  async createMemory(memory, tableName) {
    logger.debug("DrizzleAdapter createMemory:", {
      memoryId: memory.id,
      embeddingLength: memory.embedding?.length,
      contentLength: memory.content?.text?.length
    });
    const memoryId = memory.id ?? v4();
    const existing = await this.getMemoryById(memoryId);
    if (existing) {
      logger.debug("Memory already exists, skipping creation:", {
        memoryId
      });
      return memoryId;
    }
    let isUnique = true;
    if (memory.embedding && Array.isArray(memory.embedding)) {
      const similarMemories = await this.searchMemoriesByEmbedding(memory.embedding, {
        tableName,
        // Use the scope fields from the memory object for similarity check
        roomId: memory.roomId,
        worldId: memory.worldId,
        entityId: memory.entityId,
        match_threshold: 0.95,
        count: 1
      });
      isUnique = similarMemories.length === 0;
    }
    const contentToInsert = typeof memory.content === "string" ? JSON.parse(memory.content) : memory.content;
    await this.db.transaction(async (tx) => {
      await tx.insert(memoryTable).values([
        {
          id: memoryId,
          type: tableName,
          content: sql13`${contentToInsert}::jsonb`,
          metadata: sql13`${memory.metadata || {}}::jsonb`,
          entityId: memory.entityId,
          roomId: memory.roomId,
          worldId: memory.worldId,
          // Include worldId
          agentId: this.agentId,
          unique: memory.unique ?? isUnique,
          createdAt: memory.createdAt
        }
      ]);
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const embeddingValues = {
          id: v4(),
          memoryId,
          createdAt: memory.createdAt
        };
        const cleanVector = memory.embedding.map(
          (n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0
        );
        embeddingValues[this.embeddingDimension] = cleanVector;
        await tx.insert(embeddingTable).values([embeddingValues]);
      }
    });
    return memoryId;
  }
  /**
   * Updates an existing memory in the database.
   * @param memory The memory object with updated content and optional embedding
   * @returns Promise resolving to boolean indicating success
   */
  async updateMemory(memory) {
    return this.withDatabase(async () => {
      try {
        logger.debug("Updating memory:", {
          memoryId: memory.id,
          hasEmbedding: !!memory.embedding
        });
        await this.db.transaction(async (tx) => {
          if (memory.content) {
            const contentToUpdate = typeof memory.content === "string" ? JSON.parse(memory.content) : memory.content;
            await tx.update(memoryTable).set({
              content: sql13`${contentToUpdate}::jsonb`,
              ...memory.metadata && { metadata: sql13`${memory.metadata}::jsonb` }
            }).where(eq(memoryTable.id, memory.id));
          } else if (memory.metadata) {
            await tx.update(memoryTable).set({
              metadata: sql13`${memory.metadata}::jsonb`
            }).where(eq(memoryTable.id, memory.id));
          }
          if (memory.embedding && Array.isArray(memory.embedding)) {
            const cleanVector = memory.embedding.map(
              (n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0
            );
            const existingEmbedding = await tx.select({ id: embeddingTable.id }).from(embeddingTable).where(eq(embeddingTable.memoryId, memory.id)).limit(1);
            if (existingEmbedding.length > 0) {
              const updateValues = {};
              updateValues[this.embeddingDimension] = cleanVector;
              await tx.update(embeddingTable).set(updateValues).where(eq(embeddingTable.memoryId, memory.id));
            } else {
              const embeddingValues = {
                id: v4(),
                memoryId: memory.id,
                createdAt: Date.now()
              };
              embeddingValues[this.embeddingDimension] = cleanVector;
              await tx.insert(embeddingTable).values([embeddingValues]);
            }
          }
        });
        logger.debug("Memory updated successfully:", {
          memoryId: memory.id
        });
        return true;
      } catch (error) {
        logger.error("Error updating memory:", {
          error: error instanceof Error ? error.message : String(error),
          memoryId: memory.id
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously deletes a memory from the database based on the provided parameters.
   * @param {UUID} memoryId - The ID of the memory to delete.
   * @returns {Promise<void>} A Promise that resolves when the memory is deleted.
   */
  async deleteMemory(memoryId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await this.deleteMemoryFragments(tx, memoryId);
        await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        await tx.delete(memoryTable).where(eq(memoryTable.id, memoryId));
      });
      logger.debug("Memory and related fragments removed successfully:", {
        memoryId
      });
    });
  }
  /**
   * Deletes all memory fragments that reference a specific document memory
   * @param tx The database transaction
   * @param documentId The UUID of the document memory whose fragments should be deleted
   * @private
   */
  async deleteMemoryFragments(tx, documentId) {
    const fragmentsToDelete = await this.getMemoryFragments(tx, documentId);
    if (fragmentsToDelete.length > 0) {
      const fragmentIds = fragmentsToDelete.map((f) => f.id);
      await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, fragmentIds));
      await tx.delete(memoryTable).where(inArray(memoryTable.id, fragmentIds));
      logger.debug("Deleted related fragments:", {
        documentId,
        fragmentCount: fragmentsToDelete.length
      });
    }
  }
  /**
   * Retrieves all memory fragments that reference a specific document memory
   * @param tx The database transaction
   * @param documentId The UUID of the document memory whose fragments should be retrieved
   * @returns An array of memory fragments
   * @private
   */
  async getMemoryFragments(tx, documentId) {
    const fragments = await tx.select({ id: memoryTable.id }).from(memoryTable).where(
      and(
        eq(memoryTable.agentId, this.agentId),
        sql13`${memoryTable.metadata}->>'documentId' = ${documentId}`
      )
    );
    return fragments.map((f) => ({ id: f.id }));
  }
  /**
   * Asynchronously deletes all memories from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to delete memories from.
   * @param {string} tableName - The name of the table to delete memories from.
   * @returns {Promise<void>} A Promise that resolves when the memories are deleted.
   */
  async deleteAllMemories(roomId, tableName) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const rows = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
        const ids = rows.map((r) => r.id);
        logger.debug("[deleteAllMemories] memory IDs to delete:", { roomId, tableName, ids });
        if (ids.length === 0) {
          return;
        }
        await Promise.all(
          ids.map(async (memoryId) => {
            await this.deleteMemoryFragments(tx, memoryId);
            await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
          })
        );
        await tx.delete(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
      });
      logger.debug("All memories removed successfully:", { roomId, tableName });
    });
  }
  /**
   * Asynchronously counts the number of memories in the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to count memories in.
   * @param {boolean} [unique] - Whether to count unique memories only.
   * @param {string} [tableName] - The name of the table to count memories in.
   * @returns {Promise<number>} A Promise that resolves to the number of memories.
   */
  async countMemories(roomId, unique7 = true, tableName = "") {
    if (!tableName) throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)];
      if (unique7) {
        conditions.push(eq(memoryTable.unique, true));
      }
      const result = await this.db.select({ count: sql13`count(*)` }).from(memoryTable).where(and(...conditions));
      return Number(result[0]?.count ?? 0);
    });
  }
  /**
   * Asynchronously retrieves rooms from the database based on the provided parameters.
   * @param {UUID[]} roomIds - The IDs of the rooms to retrieve.
   * @returns {Promise<Room[] | null>} A Promise that resolves to the rooms if found, null otherwise.
   */
  async getRoomsByIds(roomIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: roomTable.id,
        name: roomTable.name,
        // Added name
        channelId: roomTable.channelId,
        agentId: roomTable.agentId,
        serverId: roomTable.serverId,
        worldId: roomTable.worldId,
        type: roomTable.type,
        source: roomTable.source,
        metadata: roomTable.metadata
        // Added metadata
      }).from(roomTable).where(and(inArray(roomTable.id, roomIds), eq(roomTable.agentId, this.agentId)));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? void 0,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  /**
   * Asynchronously retrieves all rooms from the database based on the provided parameters.
   * @param {UUID} worldId - The ID of the world to retrieve rooms from.
   * @returns {Promise<Room[]>} A Promise that resolves to an array of rooms.
   */
  async getRoomsByWorld(worldId) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(roomTable).where(eq(roomTable.worldId, worldId));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? void 0,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  /**
   * Asynchronously updates a room in the database based on the provided parameters.
   * @param {Room} room - The room object to update.
   * @returns {Promise<void>} A Promise that resolves when the room is updated.
   */
  async updateRoom(room) {
    return this.withDatabase(async () => {
      await this.db.update(roomTable).set({ ...room, agentId: this.agentId }).where(eq(roomTable.id, room.id));
    });
  }
  /**
   * Asynchronously creates a new room in the database based on the provided parameters.
   * @param {Room} room - The room object to create.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created room.
   */
  async createRooms(rooms) {
    return this.withDatabase(async () => {
      const roomsWithIds = rooms.map((room) => ({
        ...room,
        id: room.id || v4()
        // ensure each room has a unique ID
      }));
      const insertedRooms = await this.db.insert(roomTable).values(roomsWithIds).onConflictDoNothing().returning();
      const insertedIds = insertedRooms.map((r) => r.id);
      return insertedIds;
    });
  }
  /**
   * Asynchronously deletes a room from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to delete.
   * @returns {Promise<void>} A Promise that resolves when the room is deleted.
   */
  async deleteRoom(roomId) {
    if (!roomId) throw new Error("Room ID is required");
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(roomTable).where(eq(roomTable.id, roomId));
      });
    });
  }
  /**
   * Asynchronously retrieves all rooms for a participant from the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to retrieve rooms for.
   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.
   */
  async getRoomsForParticipant(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(eq(participantTable.entityId, entityId), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  /**
   * Asynchronously retrieves all rooms for a list of participants from the database based on the provided parameters.
   * @param {UUID[]} entityIds - The IDs of the entities to retrieve rooms for.
   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.
   */
  async getRoomsForParticipants(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.selectDistinct({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(
        and(inArray(participantTable.entityId, entityIds), eq(roomTable.agentId, this.agentId))
      );
      return result.map((row) => row.roomId);
    });
  }
  /**
   * Asynchronously adds a participant to a room in the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to add to the room.
   * @param {UUID} roomId - The ID of the room to add the entity to.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was added successfully.
   */
  async addParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(participantTable).values({
          entityId,
          roomId,
          agentId: this.agentId
        }).onConflictDoNothing();
        return true;
      } catch (error) {
        logger.error("Error adding participant", {
          error: error instanceof Error ? error.message : String(error),
          entityId,
          roomId,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  async addParticipantsRoom(entityIds, roomId) {
    return this.withDatabase(async () => {
      try {
        const values = entityIds.map((id) => ({
          entityId: id,
          roomId,
          agentId: this.agentId
        }));
        await this.db.insert(participantTable).values(values).onConflictDoNothing().execute();
        logger.debug(entityIds.length, "Entities linked successfully");
        return true;
      } catch (error) {
        logger.error("Error adding participants", {
          error: error instanceof Error ? error.message : String(error),
          entityIdSample: entityIds[0],
          roomId,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously removes a participant from a room in the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to remove from the room.
   * @param {UUID} roomId - The ID of the room to remove the entity from.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was removed successfully.
   */
  async removeParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.transaction(async (tx) => {
          return await tx.delete(participantTable).where(
            and(eq(participantTable.entityId, entityId), eq(participantTable.roomId, roomId))
          ).returning();
        });
        const removed = result.length > 0;
        logger.debug(`Participant ${removed ? "removed" : "not found"}:`, {
          entityId,
          roomId,
          removed
        });
        return removed;
      } catch (error) {
        logger.error("Failed to remove participant:", {
          error: error instanceof Error ? error.message : String(error),
          entityId,
          roomId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously retrieves all participants for an entity from the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to retrieve participants for.
   * @returns {Promise<Participant[]>} A Promise that resolves to an array of participants.
   */
  async getParticipantsForEntity(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: participantTable.id,
        entityId: participantTable.entityId,
        roomId: participantTable.roomId
      }).from(participantTable).where(eq(participantTable.entityId, entityId));
      const entities = await this.getEntityByIds([entityId]);
      if (!entities || !entities.length) {
        return [];
      }
      return result.map((row) => ({
        id: row.id,
        entity: entities[0]
      }));
    });
  }
  /**
   * Asynchronously retrieves all participants for a room from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to retrieve participants for.
   * @returns {Promise<UUID[]>} A Promise that resolves to an array of entity IDs.
   */
  async getParticipantsForRoom(roomId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ entityId: participantTable.entityId }).from(participantTable).where(eq(participantTable.roomId, roomId));
      return result.map((row) => row.entityId);
    });
  }
  /**
   * Asynchronously retrieves the user state for a participant in a room from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to retrieve the participant's user state for.
   * @param {UUID} entityId - The ID of the entity to retrieve the user state for.
   * @returns {Promise<"FOLLOWED" | "MUTED" | null>} A Promise that resolves to the participant's user state.
   */
  async getParticipantUserState(roomId, entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomState: participantTable.roomState }).from(participantTable).where(
        and(
          eq(participantTable.roomId, roomId),
          eq(participantTable.entityId, entityId),
          eq(participantTable.agentId, this.agentId)
        )
      ).limit(1);
      return result[0]?.roomState ?? null;
    });
  }
  /**
   * Asynchronously sets the user state for a participant in a room in the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to set the participant's user state for.
   * @param {UUID} entityId - The ID of the entity to set the user state for.
   * @param {string} state - The state to set the participant's user state to.
   * @returns {Promise<void>} A Promise that resolves when the participant's user state is set.
   */
  async setParticipantUserState(roomId, entityId, state) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.update(participantTable).set({ roomState: state }).where(
            and(
              eq(participantTable.roomId, roomId),
              eq(participantTable.entityId, entityId),
              eq(participantTable.agentId, this.agentId)
            )
          );
        });
      } catch (error) {
        logger.error("Failed to set participant user state:", {
          roomId,
          entityId,
          state,
          error: error instanceof Error ? error.message : String(error)
        });
        throw error;
      }
    });
  }
  /**
   * Asynchronously creates a new relationship in the database based on the provided parameters.
   * @param {Object} params - The parameters for creating a new relationship.
   * @param {UUID} params.sourceEntityId - The ID of the source entity.
   * @param {UUID} params.targetEntityId - The ID of the target entity.
   * @param {string[]} [params.tags] - The tags for the relationship.
   * @param {Object} [params.metadata] - The metadata for the relationship.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the relationship was created successfully.
   */
  async createRelationship(params) {
    return this.withDatabase(async () => {
      const id = v4();
      const saveParams = {
        id,
        sourceEntityId: params.sourceEntityId,
        targetEntityId: params.targetEntityId,
        agentId: this.agentId,
        tags: params.tags || [],
        metadata: params.metadata || {}
      };
      try {
        await this.db.insert(relationshipTable).values(saveParams);
        return true;
      } catch (error) {
        logger.error("Error creating relationship:", {
          error: error instanceof Error ? error.message : String(error),
          saveParams
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously updates an existing relationship in the database based on the provided parameters.
   * @param {Relationship} relationship - The relationship object to update.
   * @returns {Promise<void>} A Promise that resolves when the relationship is updated.
   */
  async updateRelationship(relationship) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(relationshipTable).set({
          tags: relationship.tags || [],
          metadata: relationship.metadata || {}
        }).where(eq(relationshipTable.id, relationship.id));
      } catch (error) {
        logger.error("Error updating relationship:", {
          error: error instanceof Error ? error.message : String(error),
          relationship
        });
        throw error;
      }
    });
  }
  /**
   * Asynchronously retrieves a relationship from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving a relationship.
   * @param {UUID} params.sourceEntityId - The ID of the source entity.
   * @param {UUID} params.targetEntityId - The ID of the target entity.
   * @returns {Promise<Relationship | null>} A Promise that resolves to the relationship if found, null otherwise.
   */
  async getRelationship(params) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select().from(relationshipTable).where(
          and(
            eq(relationshipTable.sourceEntityId, params.sourceEntityId),
            eq(relationshipTable.targetEntityId, params.targetEntityId),
            eq(relationshipTable.agentId, this.agentId)
          )
        ).limit(1);
        if (result.length === 0) {
          return null;
        }
        return {
          id: result[0].id,
          sourceEntityId: result[0].sourceEntityId,
          targetEntityId: result[0].targetEntityId,
          agentId: result[0].agentId,
          tags: result[0].tags || [],
          metadata: result[0].metadata || {},
          createdAt: result[0].createdAt?.toString()
        };
      } catch (error) {
        logger.error("Error getting relationship:", {
          error: error instanceof Error ? error.message : String(error),
          params
        });
        return null;
      }
    });
  }
  /**
   * Asynchronously retrieves all relationships from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving relationships.
   * @param {UUID} params.entityId - The ID of the entity to retrieve relationships for.
   * @param {string[]} [params.tags] - The tags to filter relationships by.
   * @returns {Promise<Relationship[]>} A Promise that resolves to an array of relationships.
   */
  async getRelationships(params) {
    return this.withDatabase(async () => {
      const conditions = [
        or(
          eq(relationshipTable.sourceEntityId, params.entityId),
          eq(relationshipTable.targetEntityId, params.entityId)
        ),
        eq(relationshipTable.agentId, this.agentId),
        ...params.tags && params.tags.length > 0 ? [
          sql13`${relationshipTable.tags} @> ARRAY[${sql13.raw(
            params.tags.map((tag) => `'${tag.replace(/'/g, "''")}'`).join(", ")
          )}]::text[]`
        ] : []
      ];
      const results = await this.db.select().from(relationshipTable).where(and(...conditions));
      return results.map((row) => ({
        id: row.id,
        sourceEntityId: row.sourceEntityId,
        targetEntityId: row.targetEntityId,
        agentId: row.agentId,
        tags: row.tags || [],
        metadata: row.metadata || {},
        createdAt: row.createdAt?.toString()
      }));
    });
  }
  /**
   * Asynchronously retrieves a cache value from the database based on the provided key.
   * @param {string} key - The key to retrieve the cache value for.
   * @returns {Promise<T | undefined>} A Promise that resolves to the cache value if found, undefined otherwise.
   */
  async getCache(key) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select().from(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));
        return result[0]?.value;
      } catch (error) {
        logger.error("Error fetching cache", {
          error: error instanceof Error ? error.message : String(error),
          key,
          agentId: this.agentId
        });
        return void 0;
      }
    });
  }
  /**
   * Asynchronously sets a cache value in the database based on the provided key and value.
   * @param {string} key - The key to set the cache value for.
   * @param {T} value - The value to set in the cache.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was set successfully.
   */
  async setCache(key, value) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.insert(cacheTable).values({
            key,
            agentId: this.agentId,
            value
          }).onConflictDoUpdate({
            target: [cacheTable.key, cacheTable.agentId],
            set: {
              value
            }
          });
        });
        return true;
      } catch (error) {
        logger.error("Error setting cache", {
          error: error instanceof Error ? error.message : String(error),
          key,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously deletes a cache value from the database based on the provided key.
   * @param {string} key - The key to delete the cache value for.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was deleted successfully.
   */
  async deleteCache(key) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.delete(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));
        });
        return true;
      } catch (error) {
        logger.error("Error deleting cache", {
          error: error instanceof Error ? error.message : String(error),
          key,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously creates a new world in the database based on the provided parameters.
   * @param {World} world - The world object to create.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created world.
   */
  async createWorld(world) {
    return this.withDatabase(async () => {
      const newWorldId = world.id || v4();
      await this.db.insert(worldTable).values({
        ...world,
        id: newWorldId,
        name: world.name || ""
      });
      return newWorldId;
    });
  }
  /**
   * Asynchronously retrieves a world from the database based on the provided parameters.
   * @param {UUID} id - The ID of the world to retrieve.
   * @returns {Promise<World | null>} A Promise that resolves to the world if found, null otherwise.
   */
  async getWorld(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.id, id));
      return result[0];
    });
  }
  /**
   * Asynchronously retrieves all worlds from the database based on the provided parameters.
   * @returns {Promise<World[]>} A Promise that resolves to an array of worlds.
   */
  async getAllWorlds() {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.agentId, this.agentId));
      return result;
    });
  }
  /**
   * Asynchronously updates an existing world in the database based on the provided parameters.
   * @param {World} world - The world object to update.
   * @returns {Promise<void>} A Promise that resolves when the world is updated.
   */
  async updateWorld(world) {
    return this.withDatabase(async () => {
      await this.db.update(worldTable).set(world).where(eq(worldTable.id, world.id));
    });
  }
  /**
   * Asynchronously removes a world from the database based on the provided parameters.
   * @param {UUID} id - The ID of the world to remove.
   * @returns {Promise<void>} A Promise that resolves when the world is removed.
   */
  async removeWorld(id) {
    return this.withDatabase(async () => {
      await this.db.delete(worldTable).where(eq(worldTable.id, id));
    });
  }
  /**
   * Asynchronously creates a new task in the database based on the provided parameters.
   * @param {Task} task - The task object to create.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created task.
   */
  async createTask(task) {
    if (!task.worldId) {
      throw new Error("worldId is required");
    }
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const now = /* @__PURE__ */ new Date();
        const metadata = task.metadata || {};
        const values = {
          id: task.id,
          name: task.name,
          description: task.description,
          roomId: task.roomId,
          worldId: task.worldId,
          tags: task.tags,
          metadata,
          createdAt: now,
          updatedAt: now,
          agentId: this.agentId
        };
        const result = await this.db.insert(taskTable).values(values).returning();
        return result[0].id;
      });
    });
  }
  /**
   * Asynchronously retrieves tasks based on specified parameters.
   * @param params Object containing optional roomId, tags, and entityId to filter tasks
   * @returns Promise resolving to an array of Task objects
   */
  async getTasks(params) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(
          and(
            eq(taskTable.agentId, this.agentId),
            ...params.roomId ? [eq(taskTable.roomId, params.roomId)] : [],
            ...params.tags && params.tags.length > 0 ? [
              sql13`${taskTable.tags} @> ARRAY[${sql13.raw(
                params.tags.map((t) => `'${t.replace(/'/g, "''")}'`).join(", ")
              )}]::text[]`
            ] : []
          )
        );
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata
        }));
      });
    });
  }
  /**
   * Asynchronously retrieves a specific task by its name.
   * @param name The name of the task to retrieve
   * @returns Promise resolving to the Task object if found, null otherwise
   */
  async getTasksByName(name) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.name, name), eq(taskTable.agentId, this.agentId)));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        }));
      });
    });
  }
  /**
   * Asynchronously retrieves a specific task by its ID.
   * @param id The UUID of the task to retrieve
   * @returns Promise resolving to the Task object if found, null otherwise
   */
  async getTask(id) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId))).limit(1);
        if (result.length === 0) {
          return null;
        }
        const row = result[0];
        return {
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        };
      });
    });
  }
  /**
   * Asynchronously updates an existing task in the database.
   * @param id The UUID of the task to update
   * @param task Partial Task object containing the fields to update
   * @returns Promise resolving when the update is complete
   */
  async updateTask(id, task) {
    await this.withRetry(async () => {
      await this.withDatabase(async () => {
        const updateValues = {};
        if (task.name !== void 0) updateValues.name = task.name;
        if (task.description !== void 0) updateValues.description = task.description;
        if (task.roomId !== void 0) updateValues.roomId = task.roomId;
        if (task.worldId !== void 0) updateValues.worldId = task.worldId;
        if (task.tags !== void 0) updateValues.tags = task.tags;
        task.updatedAt = Date.now();
        if (task.metadata) {
          const currentTask = await this.getTask(id);
          if (currentTask) {
            const currentMetadata = currentTask.metadata || {};
            const newMetadata = {
              ...currentMetadata,
              ...task.metadata
            };
            updateValues.metadata = newMetadata;
          } else {
            updateValues.metadata = {
              ...task.metadata
            };
          }
        }
        await this.db.update(taskTable).set(updateValues).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)));
      });
    });
  }
  /**
   * Asynchronously deletes a task from the database.
   * @param id The UUID of the task to delete
   * @returns Promise resolving when the deletion is complete
   */
  async deleteTask(id) {
    return this.withDatabase(async () => {
      await this.db.delete(taskTable).where(eq(taskTable.id, id));
    });
  }
  async getMemoriesByWorldId(params) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, params.worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        return [];
      }
      const roomIds = rooms.map((room) => room.id);
      const memories = await this.getMemoriesByRoomIds({
        roomIds,
        tableName: params.tableName || "messages",
        limit: params.count
      });
      return memories;
    });
  }
  async deleteRoomsByWorldId(worldId) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        logger.debug(
          `No rooms found for worldId ${worldId} and agentId ${this.agentId} to delete.`
        );
        return;
      }
      const roomIds = rooms.map((room) => room.id);
      if (roomIds.length > 0) {
        await this.db.delete(logTable).where(inArray(logTable.roomId, roomIds));
        logger.debug(`Deleted logs for ${roomIds.length} rooms in world ${worldId}.`);
        await this.db.delete(participantTable).where(inArray(participantTable.roomId, roomIds));
        logger.debug(`Deleted participants for ${roomIds.length} rooms in world ${worldId}.`);
        const memoriesInRooms = await this.db.select({ id: memoryTable.id }).from(memoryTable).where(inArray(memoryTable.roomId, roomIds));
        const memoryIdsInRooms = memoriesInRooms.map((m) => m.id);
        if (memoryIdsInRooms.length > 0) {
          await this.db.delete(embeddingTable).where(inArray(embeddingTable.memoryId, memoryIdsInRooms));
          logger.debug(
            `Deleted embeddings for ${memoryIdsInRooms.length} memories in world ${worldId}.`
          );
          await this.db.delete(memoryTable).where(inArray(memoryTable.id, memoryIdsInRooms));
          logger.debug(`Deleted ${memoryIdsInRooms.length} memories in world ${worldId}.`);
        }
        await this.db.delete(roomTable).where(inArray(roomTable.id, roomIds));
        logger.debug(`Deleted ${roomIds.length} rooms for worldId ${worldId}.`);
      }
    });
  }
};

// src/pglite/adapter.ts
var PgliteDatabaseAdapter = class extends BaseDrizzleAdapter {
  static {
    __name(this, "PgliteDatabaseAdapter");
  }
  manager;
  embeddingDimension = DIMENSION_MAP[384];
  /**
   * Constructor for creating an instance of a class.
   * @param {UUID} agentId - The unique identifier for the agent.
   * @param {PGliteClientManager} manager - The manager for the PGlite client.
   */
  constructor(agentId, manager) {
    super(agentId);
    this.manager = manager;
    this.db = drizzle(this.manager.getConnection());
  }
  /**
   * Asynchronously runs the provided database operation while checking if the database manager is currently shutting down.
   * If the database manager is shutting down, a warning is logged and null is returned.
   *
   * @param {Function} operation - The database operation to be performed.
   * @returns {Promise<T>} A promise that resolves with the result of the database operation.
   */
  async withDatabase(operation) {
    if (this.manager.isShuttingDown()) {
      logger2.warn("Database is shutting down");
      return null;
    }
    return operation();
  }
  /**
   * Asynchronously initializes the database by running migrations using the manager.
   *
   * @returns {Promise<void>} A Promise that resolves when the database initialization is complete.
   */
  async init() {
    try {
      await this.manager.runMigrations();
    } catch (error) {
      logger2.error("Failed to initialize database:", error);
      throw error;
    }
  }
  /**
   * Asynchronously closes the manager.
   */
  async close() {
    await this.manager.close();
  }
  /**
   * Asynchronously retrieves the connection from the manager.
   *
   * @returns {Promise<PGlite>} A Promise that resolves with the connection.
   */
  async getConnection() {
    return this.manager.getConnection();
  }
};

// src/pg/adapter.ts
import { logger as logger3 } from "@elizaos/core";
import { drizzle as drizzle2 } from "drizzle-orm/node-postgres";
var PgDatabaseAdapter = class extends BaseDrizzleAdapter {
  /**
   * Constructor for creating a new instance of a class.
   * @param {UUID} agentId - The unique identifier for the agent.
   * @param {PostgresConnectionManager} manager - The Postgres connection manager for the instance.
   */
  constructor(agentId, manager) {
    super(agentId);
    this.manager = manager;
    this.manager = manager;
  }
  static {
    __name(this, "PgDatabaseAdapter");
  }
  embeddingDimension = DIMENSION_MAP[384];
  /**
   * Executes the provided operation with a database connection.
   *
   * @template T
   * @param {() => Promise<T>} operation - The operation to be executed with the database connection.
   * @returns {Promise<T>} A promise that resolves with the result of the operation.
   */
  async withDatabase(operation) {
    return await this.withRetry(async () => {
      const client = await this.manager.getClient();
      try {
        const db = drizzle2(client);
        this.db = db;
        return await operation();
      } finally {
        client.release();
      }
    });
  }
  /**
   * Asynchronously initializes the PgDatabaseAdapter by running migrations using the manager.
   * Logs a success message if initialization is successful, otherwise logs an error message.
   *
   * @returns {Promise<void>} A promise that resolves when initialization is complete.
   */
  async init() {
    try {
      await this.manager.runMigrations();
      logger3.debug("PgDatabaseAdapter initialized successfully");
    } catch (error) {
      logger3.error("Failed to initialize PgDatabaseAdapter:", error);
      throw error;
    }
  }
  /**
   * Asynchronously closes the manager associated with this instance.
   *
   * @returns A Promise that resolves once the manager is closed.
   */
  async close() {
    await this.manager.close();
  }
  /**
   * Asynchronously retrieves the connection from the manager.
   *
   * @returns {Promise<PgPool>} A Promise that resolves with the connection.
   */
  async getConnection() {
    return this.manager.getConnection();
  }
};

// src/index.ts
var GLOBAL_SINGLETONS = Symbol.for("@elizaos/plugin-sql/global-singletons");
var globalSymbols = global;
if (!globalSymbols[GLOBAL_SINGLETONS]) {
  globalSymbols[GLOBAL_SINGLETONS] = {};
}
var globalSingletons = globalSymbols[GLOBAL_SINGLETONS];
function createDatabaseAdapter(config, agentId) {
  const dataDir = resolvePgliteDir(config.dataDir);
  if (config.postgresUrl) {
    if (!globalSingletons.postgresConnectionManager) {
      globalSingletons.postgresConnectionManager = new PostgresConnectionManager(
        config.postgresUrl
      );
    }
    return new PgDatabaseAdapter(agentId, globalSingletons.postgresConnectionManager);
  }
  if (!globalSingletons.pgLiteClientManager) {
    globalSingletons.pgLiteClientManager = new PGliteClientManager({ dataDir });
  }
  return new PgliteDatabaseAdapter(agentId, globalSingletons.pgLiteClientManager);
}
__name(createDatabaseAdapter, "createDatabaseAdapter");
var sqlPlugin = {
  name: "sql",
  description: "SQL database adapter plugin using Drizzle ORM",
  init: /* @__PURE__ */ __name(async (_, runtime) => {
    const config = {
      dataDir: resolvePgliteDir(runtime.getSetting("PGLITE_DATA_DIR")),
      postgresUrl: runtime.getSetting("POSTGRES_URL")
    };
    try {
      const db = createDatabaseAdapter(config, runtime.agentId);
      logger4.success("Database connection established successfully");
      runtime.registerDatabaseAdapter(db);
    } catch (error) {
      logger4.error("Failed to initialize database:", error);
      throw error;
    }
  }, "init")
};
var index_default = sqlPlugin;
export {
  createDatabaseAdapter,
  index_default as default
};
//# sourceMappingURL=index.js.map