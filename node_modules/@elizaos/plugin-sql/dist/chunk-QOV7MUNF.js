var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/pglite/manager.ts
import { dirname as pathDirname, resolve as pathResolve } from "node:path";
import { fileURLToPath } from "node:url";
import { PGlite } from "@electric-sql/pglite";
import { fuzzystrmatch } from "@electric-sql/pglite/contrib/fuzzystrmatch";
import { vector } from "@electric-sql/pglite/vector";
import { logger } from "@elizaos/core";
import { drizzle } from "drizzle-orm/pglite";
import { migrate } from "drizzle-orm/pglite/migrator";
var PGliteClientManager = class {
  static {
    __name(this, "PGliteClientManager");
  }
  client;
  shuttingDown = false;
  shutdownTimeout = 500;
  /**
   * Constructor for creating a new instance of PGlite with the provided options.
   * Initializes the PGlite client with additional extensions.
   * @param {PGliteOptions} options - The options to configure the PGlite client.
   */
  constructor(options) {
    this.client = new PGlite({
      ...options,
      extensions: {
        vector,
        fuzzystrmatch
      }
    });
    this.setupShutdownHandlers();
  }
  /**
   * Retrieves the PostgreSQL lite connection.
   *
   * @returns {PGlite} The PostgreSQL lite connection.
   * @throws {Error} If the client manager is currently shutting down.
   */
  getConnection() {
    if (this.shuttingDown) {
      throw new Error("Client manager is shutting down");
    }
    return this.client;
  }
  /**
   * Initiates a graceful shutdown of the PGlite client.
   * Checks if the client is already in the process of shutting down.
   * Logs the start of shutdown process and sets shuttingDown flag to true.
   * Sets a timeout for the shutdown process and forces closure of database connection if timeout is reached.
   * Handles the shutdown process, closes the client connection, clears the timeout, and logs the completion of shutdown.
   * Logs any errors that occur during the shutdown process.
   */
  async gracefulShutdown() {
    if (this.shuttingDown) {
      return;
    }
    this.shuttingDown = true;
    logger.info("Starting graceful shutdown of PGlite client...");
    const timeout = setTimeout(() => {
      logger.warn("Shutdown timeout reached, forcing database connection closure...");
      this.client.close().finally(() => {
        logger.warn("Forced database connection closure complete.");
        if (process.env.NODE_ENV !== "test") {
          process.exit(1);
        }
      });
    }, this.shutdownTimeout);
    try {
      await this.client.close();
      clearTimeout(timeout);
      logger.info("PGlite client shutdown completed successfully");
      if (process.env.NODE_ENV !== "test") {
        process.exit(0);
      }
    } catch (error) {
      logger.error("Error during graceful shutdown:", error);
      if (process.env.NODE_ENV !== "test") {
        process.exit(1);
      } else {
        throw error;
      }
    }
  }
  /**
   * Sets up shutdown handlers for SIGINT, SIGTERM, and beforeExit events to gracefully shutdown the application.
   * @private
   */
  setupShutdownHandlers() {
    process.on("SIGINT", async () => {
      await this.gracefulShutdown();
    });
    process.on("SIGTERM", async () => {
      await this.gracefulShutdown();
    });
    process.on("beforeExit", async () => {
      await this.gracefulShutdown();
    });
  }
  /**
   * Initializes the client for PGlite.
   *
   * @returns {Promise<void>} A Promise that resolves when the client is initialized successfully
   */
  async initialize() {
    try {
      await this.client.waitReady;
      logger.info("PGlite client initialized successfully");
    } catch (error) {
      logger.error("Failed to initialize PGlite client:", error);
      throw error;
    }
  }
  /**
   * Asynchronously closes the resource. If the resource is not already shutting down,
   * it performs a graceful shutdown before closing.
   *
   * @returns A promise that resolves once the resource has been closed.
   */
  async close() {
    if (!this.shuttingDown) {
      await this.gracefulShutdown();
    }
  }
  /**
   * Check if the system is currently shutting down.
   *
   * @returns {boolean} True if the system is shutting down, false otherwise.
   */
  isShuttingDown() {
    return this.shuttingDown;
  }
  /**
   * Asynchronously runs database migrations using Drizzle.
   *
   * Drizzle will first check if the migrations are already applied.
   * If there is a diff between database schema and migrations, it will apply the migrations.
   * If they are already applied, it will skip them.
   *
   * @returns {Promise<void>} A Promise that resolves once the migrations are completed successfully.
   */
  async runMigrations() {
    try {
      const db = drizzle(this.client);
      const packageJsonUrl = await import.meta.resolve("@elizaos/plugin-sql/package.json");
      const packageJsonPath = fileURLToPath(packageJsonUrl);
      const packageRoot = pathDirname(packageJsonPath);
      const migrationsPath = pathResolve(packageRoot, "drizzle/migrations");
      logger.debug(
        `Resolved migrations path (pglite) using import.meta.resolve: ${migrationsPath}`
      );
      await migrate(db, {
        migrationsFolder: migrationsPath,
        migrationsSchema: "public"
      });
    } catch (error) {
      logger.error("Failed to run database migrations (pglite):", error);
    }
  }
};

// src/pg/manager.ts
import path from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
import { logger as logger2 } from "@elizaos/core";
import { drizzle as drizzle2 } from "drizzle-orm/node-postgres";
import { migrate as migrate2 } from "drizzle-orm/node-postgres/migrator";
import pkg from "pg";
var { Pool } = pkg;
var PostgresConnectionManager = class {
  static {
    __name(this, "PostgresConnectionManager");
  }
  pool;
  isShuttingDown = false;
  connectionTimeout = 5e3;
  /**
   * Constructor for creating a connection pool.
   * @param {string} connectionString - The connection string used to connect to the database.
   */
  constructor(connectionString) {
    const defaultConfig = {
      max: 20,
      idleTimeoutMillis: 3e4,
      connectionTimeoutMillis: this.connectionTimeout
    };
    this.pool = new Pool({
      ...defaultConfig,
      connectionString
    });
    this.pool.on("error", (err) => {
      logger2.error("Unexpected pool error", err);
      this.handlePoolError(err);
    });
    this.setupPoolErrorHandling();
    this.testConnection();
  }
  /**
   * Handles a pool error by attempting to reconnect the pool.
   *
   * @param {Error} error The error that occurred in the pool.
   * @throws {Error} If failed to reconnect the pool.
   */
  async handlePoolError(error) {
    logger2.error("Pool error occurred, attempting to reconnect", {
      error: error.message
    });
    try {
      await this.pool.end();
      this.pool = new Pool({
        ...this.pool.options,
        connectionTimeoutMillis: this.connectionTimeout
      });
      await this.testConnection();
      logger2.success("Pool reconnection successful");
    } catch (reconnectError) {
      logger2.error("Failed to reconnect pool", {
        error: reconnectError instanceof Error ? reconnectError.message : String(reconnectError)
      });
      throw reconnectError;
    }
  }
  /**
   * Asynchronously tests the database connection by executing a query to get the current timestamp.
   *
   * @returns {Promise<boolean>} - A Promise that resolves to true if the database connection test is successful.
   */
  async testConnection() {
    let client = null;
    try {
      client = await this.pool.connect();
      const result = await client.query("SELECT NOW()");
      logger2.success("Database connection test successful:", result.rows[0]);
      return true;
    } catch (error) {
      logger2.error("Database connection test failed:", error);
      throw new Error(`Failed to connect to database: ${error.message}`);
    } finally {
      if (client) client.release();
    }
  }
  /**
   * Sets up event listeners to handle pool cleanup on SIGINT, SIGTERM, and beforeExit events.
   */
  setupPoolErrorHandling() {
    process.on("SIGINT", async () => {
      await this.cleanup();
      process.exit(0);
    });
    process.on("SIGTERM", async () => {
      await this.cleanup();
      process.exit(0);
    });
    process.on("beforeExit", async () => {
      await this.cleanup();
    });
  }
  /**
   * Get the connection pool.
   * @returns {PgPool} The connection pool
   * @throws {Error} If the connection manager is shutting down or an error occurs when trying to get the connection from the pool
   */
  getConnection() {
    if (this.isShuttingDown) {
      throw new Error("Connection manager is shutting down");
    }
    try {
      return this.pool;
    } catch (error) {
      logger2.error("Failed to get connection from pool:", error);
      throw error;
    }
  }
  /**
   * Asynchronously acquires a database client from the connection pool.
   *
   * @returns {Promise<pkg.PoolClient>} A Promise that resolves with the acquired database client.
   * @throws {Error} If an error occurs while acquiring the database client.
   */
  async getClient() {
    try {
      return await this.pool.connect();
    } catch (error) {
      logger2.error("Failed to acquire a database client:", error);
      throw error;
    }
  }
  /**
   * Initializes the PostgreSQL connection manager by testing the connection and logging the result.
   *
   * @returns {Promise<void>} A Promise that resolves once the manager is successfully initialized
   * @throws {Error} If there is an error initializing the connection manager
   */
  async initialize() {
    try {
      await this.testConnection();
      logger2.debug("PostgreSQL connection manager initialized successfully");
    } catch (error) {
      logger2.error("Failed to initialize connection manager:", error);
      throw error;
    }
  }
  /**
   * Asynchronously close the current process by executing a cleanup function.
   * @returns A promise that resolves once the cleanup is complete.
   */
  async close() {
    await this.cleanup();
  }
  /**
   * Cleans up and closes the database pool.
   * @returns {Promise<void>} A Promise that resolves when the database pool is closed.
   */
  async cleanup() {
    try {
      await this.pool.end();
      logger2.info("Database pool closed");
    } catch (error) {
      logger2.error("Error closing database pool:", error);
    }
  }
  /**
   * Asynchronously runs database migrations using the Drizzle library.
   *
   * Drizzle will first check if the migrations are already applied.
   * If there is a diff between database schema and migrations, it will apply the migrations.
   * If they are already applied, it will skip them.
   *
   * @returns {Promise<void>} A Promise that resolves once the migrations are completed successfully.
   */
  async runMigrations() {
    try {
      const db = drizzle2(this.pool);
      const packageJsonUrl = await import.meta.resolve("@elizaos/plugin-sql/package.json");
      const packageJsonPath = fileURLToPath2(packageJsonUrl);
      const packageRoot = path.dirname(packageJsonPath);
      const migrationsPath = path.resolve(packageRoot, "drizzle/migrations");
      logger2.debug(`Resolved migrations path (pg) using import.meta.resolve: ${migrationsPath}`);
      await migrate2(db, {
        migrationsFolder: migrationsPath,
        migrationsSchema: "public"
      });
    } catch (error) {
      logger2.error("Failed to run database migrations (pg):", error);
    }
  }
};

// src/utils.ts
import dotenv from "dotenv";
import { existsSync } from "node:fs";
import path2 from "node:path";
function expandTildePath(filepath) {
  if (filepath && filepath.startsWith("~")) {
    return path2.join(process.cwd(), filepath.slice(1));
  }
  return filepath;
}
__name(expandTildePath, "expandTildePath");
function resolveEnvFile(startDir = process.cwd()) {
  let currentDir = startDir;
  while (true) {
    const candidate = path2.join(currentDir, ".env");
    if (existsSync(candidate)) {
      return candidate;
    }
    const parentDir = path2.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return path2.join(startDir, ".env");
}
__name(resolveEnvFile, "resolveEnvFile");
function resolvePgliteDir(dir, fallbackDir) {
  const envPath = resolveEnvFile();
  if (existsSync(envPath)) {
    dotenv.config({ path: envPath });
  }
  const base = dir ?? process.env.PGLITE_DATA_DIR ?? fallbackDir ?? path2.join(process.cwd(), ".elizadb");
  return expandTildePath(base);
}
__name(resolvePgliteDir, "resolvePgliteDir");

export {
  __name,
  PGliteClientManager,
  PostgresConnectionManager,
  resolvePgliteDir
};
//# sourceMappingURL=chunk-QOV7MUNF.js.map