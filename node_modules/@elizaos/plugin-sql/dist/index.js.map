{"version":3,"sources":["../src/index.ts","../src/pglite/adapter.ts","../src/base.ts","../src/schema/embedding.ts","../src/schema/memory.ts","../src/schema/agent.ts","../src/schema/types.ts","../src/schema/entity.ts","../src/schema/room.ts","../src/schema/cache.ts","../src/schema/component.ts","../src/schema/world.ts","../src/schema/log.ts","../src/schema/participant.ts","../src/schema/relationship.ts","../src/schema/tasks.ts","../src/pg/adapter.ts"],"sourceRoot":"./","sourcesContent":["import type { IDatabaseAdapter, UUID } from '@elizaos/core';\nimport { type IAgentRuntime, type Plugin, logger } from '@elizaos/core';\nimport { PgliteDatabaseAdapter } from './pglite/adapter';\nimport { PGliteClientManager } from './pglite/manager';\nimport { PgDatabaseAdapter } from './pg/adapter';\nimport { PostgresConnectionManager } from './pg/manager';\nimport { resolvePgliteDir } from './utils';\n\n/**\n * Global Singleton Instances (Package-scoped)\n *\n * These instances are stored globally within the package scope to ensure a single shared instance across multiple adapters within this package.\n * This approach prevents multiple instantiations due to module caching or multiple imports within the same process.\n *\n * IMPORTANT:\n * - Do NOT directly modify these instances outside their intended initialization logic.\n * - These instances are NOT exported and should NOT be accessed outside this package.\n */\nconst GLOBAL_SINGLETONS = Symbol.for('@elizaos/plugin-sql/global-singletons');\n\ninterface GlobalSingletons {\n  pgLiteClientManager?: PGliteClientManager;\n  postgresConnectionManager?: PostgresConnectionManager;\n}\n\nconst globalSymbols = global as unknown as Record<symbol, GlobalSingletons>;\n\nif (!globalSymbols[GLOBAL_SINGLETONS]) {\n  globalSymbols[GLOBAL_SINGLETONS] = {};\n}\n\nconst globalSingletons = globalSymbols[GLOBAL_SINGLETONS];\n\n/**\n * Creates a database adapter based on the provided configuration.\n * If a postgresUrl is provided in the config, a PgDatabaseAdapter is initialized using the PostgresConnectionManager.\n * If no postgresUrl is provided, a PgliteDatabaseAdapter is initialized using PGliteClientManager with the dataDir from the config.\n *\n * @param {object} config - The configuration object.\n * @param {string} [config.dataDir] - The directory where data is stored. Defaults to \"./.elizadb\".\n * @param {string} [config.postgresUrl] - The URL for the PostgreSQL database.\n * @param {UUID} agentId - The unique identifier for the agent.\n * @returns {IDatabaseAdapter} The created database adapter.\n */\nexport function createDatabaseAdapter(\n  config: {\n    dataDir?: string;\n    postgresUrl?: string;\n  },\n  agentId: UUID\n): IDatabaseAdapter {\n  const dataDir = resolvePgliteDir(config.dataDir);\n\n  if (config.postgresUrl) {\n    if (!globalSingletons.postgresConnectionManager) {\n      globalSingletons.postgresConnectionManager = new PostgresConnectionManager(\n        config.postgresUrl\n      );\n    }\n    return new PgDatabaseAdapter(agentId, globalSingletons.postgresConnectionManager);\n  }\n\n  if (!globalSingletons.pgLiteClientManager) {\n    globalSingletons.pgLiteClientManager = new PGliteClientManager({ dataDir });\n  }\n\n  return new PgliteDatabaseAdapter(agentId, globalSingletons.pgLiteClientManager);\n}\n\n/**\n * SQL plugin for database adapter using Drizzle ORM\n *\n * @typedef {Object} Plugin\n * @property {string} name - The name of the plugin\n * @property {string} description - The description of the plugin\n * @property {Function} init - The initialization function for the plugin\n * @param {any} _ - Input parameter\n * @param {IAgentRuntime} runtime - The runtime environment for the agent\n */\nconst sqlPlugin: Plugin = {\n  name: 'sql',\n  description: 'SQL database adapter plugin using Drizzle ORM',\n  init: async (_, runtime: IAgentRuntime) => {\n    const config = {\n      dataDir: resolvePgliteDir(runtime.getSetting('PGLITE_DATA_DIR') as string | undefined),\n      postgresUrl: runtime.getSetting('POSTGRES_URL'),\n    };\n\n    try {\n      const db = createDatabaseAdapter(config, runtime.agentId);\n      logger.success('Database connection established successfully');\n      runtime.registerDatabaseAdapter(db);\n    } catch (error) {\n      logger.error('Failed to initialize database:', error);\n      throw error;\n    }\n  },\n};\n\nexport default sqlPlugin;\n","import { type UUID, logger } from '@elizaos/core';\nimport { type PgliteDatabase, drizzle } from 'drizzle-orm/pglite';\nimport { BaseDrizzleAdapter } from '../base';\nimport { DIMENSION_MAP, type EmbeddingDimensionColumn } from '../schema/embedding';\nimport type { PGliteClientManager } from './manager';\n\n/**\n * PgliteDatabaseAdapter class represents an adapter for interacting with a PgliteDatabase.\n * Extends BaseDrizzleAdapter<PgliteDatabase>.\n *\n * @constructor\n * @param {UUID} agentId - The ID of the agent.\n * @param {PGliteClientManager} manager - The manager for the PgliteDatabase.\n *\n * @method withDatabase\n * @param {() => Promise<T>} operation - The operation to perform on the database.\n * @return {Promise<T>} - The result of the operation.\n *\n * @method init\n * @return {Promise<void>} - A Promise that resolves when the initialization is complete.\n *\n * @method close\n * @return {void} - A Promise that resolves when the database is closed.\n */\nexport class PgliteDatabaseAdapter extends BaseDrizzleAdapter<PgliteDatabase> {\n  private manager: PGliteClientManager;\n  protected embeddingDimension: EmbeddingDimensionColumn = DIMENSION_MAP[384];\n\n  /**\n   * Constructor for creating an instance of a class.\n   * @param {UUID} agentId - The unique identifier for the agent.\n   * @param {PGliteClientManager} manager - The manager for the PGlite client.\n   */\n  constructor(agentId: UUID, manager: PGliteClientManager) {\n    super(agentId);\n    this.manager = manager;\n    this.db = drizzle(this.manager.getConnection());\n  }\n\n  /**\n   * Asynchronously runs the provided database operation while checking if the database manager is currently shutting down.\n   * If the database manager is shutting down, a warning is logged and null is returned.\n   *\n   * @param {Function} operation - The database operation to be performed.\n   * @returns {Promise<T>} A promise that resolves with the result of the database operation.\n   */\n  protected async withDatabase<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.manager.isShuttingDown()) {\n      logger.warn('Database is shutting down');\n      return null as unknown as T;\n    }\n    return operation();\n  }\n\n  /**\n   * Asynchronously initializes the database by running migrations using the manager.\n   *\n   * @returns {Promise<void>} A Promise that resolves when the database initialization is complete.\n   */\n  async init(): Promise<void> {\n    try {\n      await this.manager.runMigrations();\n    } catch (error) {\n      logger.error('Failed to initialize database:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Asynchronously closes the manager.\n   */\n  async close() {\n    await this.manager.close();\n  }\n\n  /**\n   * Asynchronously retrieves the connection from the manager.\n   *\n   * @returns {Promise<PGlite>} A Promise that resolves with the connection.\n   */\n  async getConnection() {\n    return this.manager.getConnection();\n  }\n}\n","import {\n  type Agent,\n  type Component,\n  DatabaseAdapter,\n  type Entity,\n  type Memory,\n  type MemoryMetadata,\n  type Participant,\n  type Relationship,\n  type Room,\n  type Task,\n  type UUID,\n  type World,\n  type Log,\n  logger,\n  stringToUuid,\n  TaskMetadata,\n  ChannelType,\n  RoomMetadata,\n} from '@elizaos/core';\nimport { and, cosineDistance, count, desc, eq, gte, inArray, lte, or, sql, not } from 'drizzle-orm';\nimport { v4 } from 'uuid';\nimport { DIMENSION_MAP, type EmbeddingDimensionColumn } from './schema/embedding';\nimport {\n  agentTable,\n  cacheTable,\n  componentTable,\n  embeddingTable,\n  entityTable,\n  logTable,\n  memoryTable,\n  participantTable,\n  relationshipTable,\n  roomTable,\n  taskTable,\n  worldTable,\n} from './schema/index';\nimport type { DrizzleDatabase } from './types';\n\n// Define the metadata type inline since we can't import it\n/**\n * Represents metadata information about memory.\n * @typedef {Object} MemoryMetadata\n * @property {string} type - The type of memory.\n * @property {string} [source] - The source of the memory.\n * @property {UUID} [sourceId] - The ID of the source.\n * @property {string} [scope] - The scope of the memory.\n * @property {number} [timestamp] - The timestamp of the memory.\n * @property {string[]} [tags] - The tags associated with the memory.\n * @property {UUID} [documentId] - The ID of the document associated with the memory.\n * @property {number} [position] - The position of the memory.\n */\n\n/**\n * Abstract class representing a base Drizzle adapter for working with databases.\n * This adapter provides a comprehensive set of methods for interacting with a database\n * using Drizzle ORM. It implements the DatabaseAdapter interface and handles operations\n * for various entity types including agents, entities, components, memories, rooms,\n * participants, relationships, tasks, and more.\n *\n * The adapter includes built-in retry logic for database operations, embedding dimension\n * management, and transaction support. Concrete implementations must provide the\n * withDatabase method to execute operations against their specific database.\n *\n * @template TDrizzleDatabase - The type of Drizzle operations supported by the adapter.\n */\nexport abstract class BaseDrizzleAdapter<\n  TDrizzleDatabase extends DrizzleDatabase,\n> extends DatabaseAdapter<TDrizzleDatabase> {\n  protected readonly maxRetries: number = 3;\n  protected readonly baseDelay: number = 1000;\n  protected readonly maxDelay: number = 10000;\n  protected readonly jitterMax: number = 1000;\n  protected embeddingDimension: EmbeddingDimensionColumn = DIMENSION_MAP[384];\n\n  protected abstract withDatabase<T>(operation: () => Promise<T>): Promise<T>;\n  public abstract init(): Promise<void>;\n  public abstract close(): Promise<void>;\n\n  protected agentId: UUID;\n\n  /**\n   * Constructor for creating a new instance of Agent with the specified agentId.\n   *\n   * @param {UUID} agentId - The unique identifier for the agent.\n   */\n  constructor(agentId: UUID) {\n    super();\n    this.agentId = agentId;\n  }\n\n  /**\n   * Executes the given operation with retry logic.\n   * @template T\n   * @param {() => Promise<T>} operation - The operation to be executed.\n   * @returns {Promise<T>} A promise that resolves with the result of the operation.\n   */\n  protected async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n\n        if (attempt < this.maxRetries) {\n          const backoffDelay = Math.min(this.baseDelay * 2 ** (attempt - 1), this.maxDelay);\n\n          const jitter = Math.random() * this.jitterMax;\n          const delay = backoffDelay + jitter;\n\n          logger.warn(`Database operation failed (attempt ${attempt}/${this.maxRetries}):`, {\n            error: error instanceof Error ? error.message : String(error),\n            nextRetryIn: `${(delay / 1000).toFixed(1)}s`,\n          });\n\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } else {\n          logger.error('Max retry attempts reached:', {\n            error: error instanceof Error ? error.message : String(error),\n            totalAttempts: attempt,\n          });\n          throw error instanceof Error ? error : new Error(String(error));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Asynchronously ensures that an agent exists by checking if an agent with the same name already exists in the system.\n   * If the agent does not exist, it will be created with the provided data.\n   *\n   * @param {Partial<Agent>} agent - The partial data of the agent to ensure its existence.\n   * @returns {Promise<void>} - A promise that resolves when the agent is successfully ensured.\n   * @throws {Error} - If the agent name is not provided or if there is an issue creating the agent.\n   */\n  async ensureAgentExists(agent: Partial<Agent>): Promise<Agent> {\n    if (!agent.name) {\n      throw new Error('Agent name is required');\n    }\n\n    const agents = await this.getAgents();\n\n    const existingAgentId = agents.find((a) => a.name === agent.name)?.id;\n\n    if (existingAgentId) {\n      const existingAgent = (await this.getAgent(existingAgentId)) as Agent;\n      return existingAgent;\n    }\n\n    const newAgent: Agent = {\n      ...agent,\n      id: stringToUuid(agent.name),\n    } as Agent;\n\n    await this.createAgent(newAgent);\n\n    return newAgent;\n  }\n\n  /**\n   * Asynchronously ensures that the given embedding dimension is valid for the agent.\n   *\n   * @param {number} dimension - The dimension to ensure for the embedding.\n   * @returns {Promise<void>} - Resolves once the embedding dimension is ensured.\n   */\n  async ensureEmbeddingDimension(dimension: number) {\n    return this.withDatabase(async () => {\n      const existingMemory = await this.db\n        .select({\n          embedding: embeddingTable,\n        })\n        .from(memoryTable)\n        .innerJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id))\n        .where(eq(memoryTable.agentId, this.agentId))\n        .limit(1);\n\n      if (existingMemory.length > 0) {\n        const usedDimension = Object.entries(DIMENSION_MAP).find(\n          ([_, colName]) => existingMemory[0].embedding[colName] !== null\n        );\n        // We don't actually need to use usedDimension for now, but it's good to know it's there.\n      }\n\n      this.embeddingDimension = DIMENSION_MAP[dimension];\n    });\n  }\n\n  /**\n   * Asynchronously retrieves an agent by their ID from the database.\n   * @param {UUID} agentId - The ID of the agent to retrieve.\n   * @returns {Promise<Agent | null>} A promise that resolves to the retrieved agent or null if not found.\n   */\n  async getAgent(agentId: UUID): Promise<Agent | null> {\n    return this.withDatabase(async () => {\n      const rows = await this.db\n        .select()\n        .from(agentTable)\n        .where(eq(agentTable.id, agentId))\n        .limit(1);\n\n      if (rows.length === 0) return null;\n\n      const row = rows[0];\n      return {\n        ...row,\n        username: row.username || '',\n        id: row.id as UUID,\n        system: !row.system ? undefined : row.system,\n        bio: !row.bio ? '' : row.bio,\n      };\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a list of agents from the database.\n   *\n   * @returns {Promise<Partial<Agent>[]>} A Promise that resolves to an array of Agent objects.\n   */\n  async getAgents(): Promise<Partial<Agent>[]> {\n    return this.withDatabase(async () => {\n      const rows = await this.db\n        .select({\n          id: agentTable.id,\n          name: agentTable.name,\n          bio: agentTable.bio,\n        })\n        .from(agentTable);\n      return rows.map((row) => ({\n        ...row,\n        id: row.id as UUID,\n        bio: row.bio === null ? '' : row.bio,\n      }));\n    });\n  }\n  /**\n   * Asynchronously creates a new agent record in the database.\n   *\n   * @param {Partial<Agent>} agent The agent object to be created.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating the success of the operation.\n   */\n  async createAgent(agent: Agent): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.transaction(async (tx) => {\n          await tx.insert(agentTable).values({\n            ...agent,\n          });\n        });\n\n        logger.debug('Agent created successfully:', {\n          agentId: agent.id,\n        });\n        return true;\n      } catch (error) {\n        logger.error('Error creating agent:', {\n          error: error instanceof Error ? error.message : String(error),\n          agentId: agent.id,\n          agent,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Updates an agent in the database with the provided agent ID and data.\n   * @param {UUID} agentId - The unique identifier of the agent to update.\n   * @param {Partial<Agent>} agent - The partial agent object containing the fields to update.\n   * @returns {Promise<boolean>} - A boolean indicating if the agent was successfully updated.\n   */\n  async updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        if (!agentId) {\n          throw new Error('Agent ID is required for update');\n        }\n\n        await this.db.transaction(async (tx) => {\n          // Handle settings update if present\n          if (agent?.settings) {\n            agent.settings = await this.mergeAgentSettings(tx, agentId, agent.settings);\n          }\n\n          await tx\n            .update(agentTable)\n            .set({\n              ...agent,\n              updatedAt: Date.now(),\n            })\n            .where(eq(agentTable.id, agentId));\n        });\n\n        logger.debug('Agent updated successfully:', {\n          agentId,\n        });\n        return true;\n      } catch (error) {\n        logger.error('Error updating agent:', {\n          error: error instanceof Error ? error.message : String(error),\n          agentId,\n          agent,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Merges updated agent settings with existing settings in the database,\n   * with special handling for nested objects like secrets.\n   * @param tx - The database transaction\n   * @param agentId - The ID of the agent\n   * @param updatedSettings - The settings object with updates\n   * @returns The merged settings object\n   * @private\n   */\n  private async mergeAgentSettings(\n    tx: TDrizzleDatabase,\n    agentId: UUID,\n    updatedSettings: any\n  ): Promise<any> {\n    // First get the current agent data\n    const currentAgent = await tx\n      .select({ settings: agentTable.settings })\n      .from(agentTable)\n      .where(eq(agentTable.id, agentId))\n      .limit(1);\n\n    const currentSettings =\n      currentAgent.length > 0 && currentAgent[0].settings ? currentAgent[0].settings : {};\n\n    const deepMerge = (target: any, source: any): any => {\n      // If source is explicitly null, it means the intention is to set this entire branch to null (or delete if top-level handled by caller).\n      // For recursive calls, if a sub-object in source is null, it effectively means \"remove this sub-object from target\".\n      // However, our primary deletion signal is a *property value* being null within an object.\n      if (source === null) {\n        // If the entire source for a given key is null, we treat it as \"delete this key from target\"\n        // by returning undefined, which the caller can use to delete the key.\n        return undefined;\n      }\n\n      // If source is an array or a primitive, it replaces the target value.\n      if (Array.isArray(source) || typeof source !== 'object') {\n        return source;\n      }\n\n      // Initialize output. If target is not an object, start with an empty one to merge source into.\n      const output =\n        typeof target === 'object' && target !== null && !Array.isArray(target)\n          ? { ...target }\n          : {};\n\n      let isEmpty = true; // Flag to track if the resulting object is empty\n      for (const key of Object.keys(source)) {\n        // Iterate over source keys\n        const sourceValue = source[key];\n\n        if (sourceValue === null) {\n          // If a value in source is null, delete the corresponding key from output.\n          delete output[key];\n        } else if (typeof sourceValue === 'object' && !Array.isArray(sourceValue)) {\n          // If value is an object, recurse.\n          const nestedMergeResult = deepMerge(output[key], sourceValue);\n          if (nestedMergeResult === undefined) {\n            // If recursive merge resulted in undefined (meaning the nested object should be deleted)\n            delete output[key];\n          } else {\n            output[key] = nestedMergeResult;\n            isEmpty = false; // The object is not empty if it has a nested object\n          }\n        } else {\n          // Primitive or array value from source, assign it.\n          output[key] = sourceValue;\n          isEmpty = false; // The object is not empty\n        }\n      }\n\n      // After processing all keys from source, check if output became empty.\n      // An object is empty if all its keys were deleted or resulted in undefined.\n      // This is a more direct check than iterating 'output' after building it.\n      if (Object.keys(output).length === 0) {\n        // If the source itself was not an explicitly empty object,\n        // and the merge resulted in an empty object, signal deletion.\n        if (!(typeof source === 'object' && source !== null && Object.keys(source).length === 0)) {\n          return undefined; // Signal to delete this (parent) key if it became empty.\n        }\n      }\n\n      return output;\n    }; // End of deepMerge\n\n    const finalSettings = deepMerge(currentSettings, updatedSettings);\n    // If the entire settings object becomes undefined (e.g. all keys removed),\n    // return an empty object instead of undefined/null to keep the settings field present.\n    return finalSettings === undefined ? {} : finalSettings;\n  }\n\n  /**\n   * Asynchronously deletes an agent with the specified UUID and all related entries.\n   *\n   * @param {UUID} agentId - The UUID of the agent to be deleted.\n   * @returns {Promise<boolean>} - A boolean indicating if the deletion was successful.\n   */\n  async deleteAgent(agentId: UUID): Promise<boolean> {\n    logger.debug(`[DB] Starting deletion of agent with ID: ${agentId}`);\n\n    return this.withDatabase(async () => {\n      try {\n        logger.debug(`[DB] Beginning database transaction for deleting agent: ${agentId}`);\n\n        // Use a transaction with timeout\n        const deletePromise = new Promise<boolean>((resolve, reject) => {\n          const timeoutId = setTimeout(() => {\n            logger.error(`[DB] Transaction timeout reached for agent deletion: ${agentId}`);\n            reject(new Error('Database transaction timeout'));\n          }, 30000);\n\n          this.db\n            .transaction(async (tx: DrizzleDatabase) => {\n              try {\n                // Step 1: Find all entities belonging to this agent\n                logger.debug(`[DB] Fetching entities for agent: ${agentId}`);\n                const entities = await tx\n                  .select({ entityId: entityTable.id })\n                  .from(entityTable)\n                  .where(eq(entityTable.agentId, agentId));\n\n                const entityIds = entities.map((e) => e.entityId);\n                logger.debug(\n                  `[DB] Found ${entityIds.length} entities to delete for agent ${agentId}`\n                );\n\n                // Step 2: Find all rooms for this agent\n                logger.debug(`[DB] Fetching rooms for agent: ${agentId}`);\n                const rooms = await tx\n                  .select({ roomId: roomTable.id })\n                  .from(roomTable)\n                  .where(eq(roomTable.agentId, agentId));\n\n                const roomIds = rooms.map((r) => r.roomId);\n                logger.debug(`[DB] Found ${roomIds.length} rooms for agent ${agentId}`);\n\n                // Delete logs first directly, addressing the foreign key constraint\n                logger.debug(\n                  `[DB] Explicitly deleting ALL logs with matching entityIds and roomIds`\n                );\n\n                // Delete logs by entity IDs\n                if (entityIds.length > 0) {\n                  logger.debug(`[DB] Deleting logs for ${entityIds.length} entities (first batch)`);\n                  // Break into smaller batches if there are many entities\n                  const BATCH_SIZE = 50;\n                  for (let i = 0; i < entityIds.length; i += BATCH_SIZE) {\n                    const batch = entityIds.slice(i, i + BATCH_SIZE);\n                    logger.debug(\n                      `[DB] Processing entity logs batch ${i / BATCH_SIZE + 1} with ${batch.length} entities`\n                    );\n                    await tx.delete(logTable).where(inArray(logTable.entityId, batch));\n                  }\n                  logger.debug(`[DB] Entity logs deletion completed successfully`);\n                }\n\n                // Delete logs by room IDs\n                if (roomIds.length > 0) {\n                  logger.debug(`[DB] Deleting logs for ${roomIds.length} rooms (first batch)`);\n                  // Break into smaller batches if there are many rooms\n                  const BATCH_SIZE = 50;\n                  for (let i = 0; i < roomIds.length; i += BATCH_SIZE) {\n                    const batch = roomIds.slice(i, i + BATCH_SIZE);\n                    logger.debug(\n                      `[DB] Processing room logs batch ${i / BATCH_SIZE + 1} with ${batch.length} rooms`\n                    );\n                    await tx.delete(logTable).where(inArray(logTable.roomId, batch));\n                  }\n                  logger.debug(`[DB] Room logs deletion completed successfully`);\n                }\n\n                // Step 3: Find memories that belong to entities\n                let memoryIds: UUID[] = [];\n                if (entityIds.length > 0) {\n                  logger.debug(`[DB] Finding memories belonging to entities`);\n                  const memories = await tx\n                    .select({ id: memoryTable.id })\n                    .from(memoryTable)\n                    .where(inArray(memoryTable.entityId, entityIds));\n\n                  memoryIds = memories.map((m) => m.id as UUID);\n                  logger.debug(`[DB] Found ${memoryIds.length} memories belonging to entities`);\n                }\n\n                // Step 4: Find memories that belong to the agent\n                logger.debug(`[DB] Finding memories belonging to agent directly`);\n                const agentMemories = await tx\n                  .select({ id: memoryTable.id })\n                  .from(memoryTable)\n                  .where(eq(memoryTable.agentId, agentId));\n\n                memoryIds = [...memoryIds, ...agentMemories.map((m) => m.id as UUID)];\n                logger.debug(`[DB] Found total of ${memoryIds.length} memories to delete`);\n\n                // Step 5: Find memories that belong to the rooms\n                if (roomIds.length > 0) {\n                  logger.debug(`[DB] Finding memories belonging to rooms`);\n                  const roomMemories = await tx\n                    .select({ id: memoryTable.id })\n                    .from(memoryTable)\n                    .where(inArray(memoryTable.roomId, roomIds));\n\n                  memoryIds = [...memoryIds, ...roomMemories.map((m) => m.id as UUID)];\n                  logger.debug(`[DB] Updated total to ${memoryIds.length} memories to delete`);\n                }\n\n                // Step 6: Delete embeddings for memories\n                if (memoryIds.length > 0) {\n                  logger.debug(`[DB] Deleting embeddings for ${memoryIds.length} memories`);\n                  // Delete in smaller batches if there are many memories\n                  const BATCH_SIZE = 100;\n                  for (let i = 0; i < memoryIds.length; i += BATCH_SIZE) {\n                    const batch = memoryIds.slice(i, i + BATCH_SIZE);\n                    await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, batch));\n                  }\n                  logger.debug(`[DB] Embeddings deleted successfully`);\n                }\n\n                // Step 7: Delete memories\n                if (memoryIds.length > 0) {\n                  logger.debug(`[DB] Deleting ${memoryIds.length} memories`);\n                  // Delete in smaller batches if there are many memories\n                  const BATCH_SIZE = 100;\n                  for (let i = 0; i < memoryIds.length; i += BATCH_SIZE) {\n                    const batch = memoryIds.slice(i, i + BATCH_SIZE);\n                    await tx.delete(memoryTable).where(inArray(memoryTable.id, batch));\n                  }\n                  logger.debug(`[DB] Memories deleted successfully`);\n                }\n\n                // Step 8: Delete components for entities\n                if (entityIds.length > 0) {\n                  logger.debug(`[DB] Deleting components for entities`);\n                  await tx\n                    .delete(componentTable)\n                    .where(inArray(componentTable.entityId, entityIds));\n                  logger.debug(`[DB] Components deleted successfully`);\n                }\n\n                // Step 9: Delete source entity references in components\n                if (entityIds.length > 0) {\n                  logger.debug(`[DB] Deleting source entity references in components`);\n                  await tx\n                    .delete(componentTable)\n                    .where(inArray(componentTable.sourceEntityId, entityIds));\n                  logger.debug(`[DB] Source entity references deleted successfully`);\n                }\n\n                // Step 10: Delete participations for rooms\n                if (roomIds.length > 0) {\n                  logger.debug(`[DB] Deleting participations for rooms`);\n                  await tx\n                    .delete(participantTable)\n                    .where(inArray(participantTable.roomId, roomIds));\n                  logger.debug(`[DB] Participations deleted for rooms`);\n                }\n\n                // Step 11: Delete agent-related participations\n                logger.debug(`[DB] Deleting agent participations`);\n                await tx.delete(participantTable).where(eq(participantTable.agentId, agentId));\n                logger.debug(`[DB] Agent participations deleted`);\n\n                // Step 12: Delete rooms\n                if (roomIds.length > 0) {\n                  logger.debug(`[DB] Deleting rooms`);\n                  await tx.delete(roomTable).where(inArray(roomTable.id, roomIds));\n                  logger.debug(`[DB] Rooms deleted successfully`);\n                }\n\n                // Step 13: Delete cache entries\n                logger.debug(`[DB] Deleting cache entries`);\n                await tx.delete(cacheTable).where(eq(cacheTable.agentId, agentId));\n                logger.debug(`[DB] Cache entries deleted successfully`);\n\n                // Step 14: Delete relationships\n                logger.debug(`[DB] Deleting relationships`);\n                // First delete where source entity is from this agent\n                if (entityIds.length > 0) {\n                  await tx\n                    .delete(relationshipTable)\n                    .where(inArray(relationshipTable.sourceEntityId, entityIds));\n                  // Then delete where target entity is from this agent\n                  await tx\n                    .delete(relationshipTable)\n                    .where(inArray(relationshipTable.targetEntityId, entityIds));\n                }\n                // Finally, delete by agent ID\n                await tx.delete(relationshipTable).where(eq(relationshipTable.agentId, agentId));\n                logger.debug(`[DB] Relationships deleted successfully`);\n\n                // Step 15: Delete entities\n                if (entityIds.length > 0) {\n                  logger.debug(`[DB] Deleting entities`);\n                  await tx.delete(entityTable).where(eq(entityTable.agentId, agentId));\n                  logger.debug(`[DB] Entities deleted successfully`);\n                }\n\n                // Step 16: Handle world references\n                logger.debug(`[DB] Checking for world references`);\n                const worlds = await tx\n                  .select({ id: worldTable.id })\n                  .from(worldTable)\n                  .where(eq(worldTable.agentId, agentId));\n\n                if (worlds.length > 0) {\n                  const worldIds = worlds.map((w) => w.id);\n                  logger.debug(`[DB] Found ${worldIds.length} worlds to delete`);\n\n                  // Step 17: Delete worlds\n                  await tx.delete(worldTable).where(inArray(worldTable.id, worldIds));\n                  logger.debug(`[DB] Worlds deleted successfully`);\n                } else {\n                  logger.debug(`[DB] No worlds found for this agent`);\n                }\n\n                // Step 18: Finally, delete the agent\n                logger.debug(`[DB] Deleting agent ${agentId}`);\n                await tx.delete(agentTable).where(eq(agentTable.id, agentId));\n                logger.debug(`[DB] Agent deleted successfully`);\n\n                resolve(true);\n              } catch (error) {\n                logger.error(`[DB] Error in transaction:`, error);\n                reject(error);\n              }\n            })\n            .catch((transactionError) => {\n              clearTimeout(timeoutId);\n              reject(transactionError);\n            });\n        });\n\n        await deletePromise;\n        logger.success(`[DB] Agent ${agentId} successfully deleted`);\n        return true;\n      } catch (error) {\n        logger.error(`[DB] Error in database transaction for agent deletion ${agentId}:`, error);\n        if (error instanceof Error) {\n          logger.error(`[DB] Error name: ${error.name}, message: ${error.message}`);\n          logger.error(`[DB] Error stack: ${error.stack}`);\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Count all agents in the database\n   * Used primarily for maintenance and cleanup operations\n   */\n  /**\n   * Asynchronously counts the number of agents in the database.\n   * @returns {Promise<number>} A Promise that resolves to the number of agents in the database.\n   */\n  async countAgents(): Promise<number> {\n    return this.withDatabase(async () => {\n      try {\n        const result = await this.db.select({ count: count() }).from(agentTable);\n\n        return result[0]?.count || 0;\n      } catch (error) {\n        logger.error('Error counting agents:', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        return 0;\n      }\n    });\n  }\n\n  /**\n   * Clean up the agents table by removing all agents\n   * This is used during server startup to ensure no orphaned agents exist\n   * from previous crashes or improper shutdowns\n   */\n  async cleanupAgents(): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.delete(agentTable);\n        logger.success('Successfully cleaned up agent table');\n      } catch (error) {\n        logger.error('Error cleaning up agent table:', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously retrieves an entity and its components by entity IDs.\n   * @param {UUID[]} entityIds - The unique identifiers of the entities to retrieve.\n   * @returns {Promise<Entity[] | null>} A Promise that resolves to the entity with its components if found, null otherwise.\n   */\n  async getEntityByIds(entityIds: UUID[]): Promise<Entity[] | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          entity: entityTable,\n          components: componentTable,\n        })\n        .from(entityTable)\n        .leftJoin(componentTable, eq(componentTable.entityId, entityTable.id))\n        .where(inArray(entityTable.id, entityIds));\n\n      if (result.length === 0) return null;\n\n      // Group components by entity\n      const entities: Record<UUID, Entity> = {};\n      const entityComponents: Record<UUID, Entity['components']> = {};\n      for (const e of result) {\n        const key = e.entity.id;\n        entities[key] = e.entity;\n        if (entityComponents[key] === undefined) entityComponents[key] = [];\n        if (e.components) {\n          // Handle both single component and array of components\n          const componentsArray = Array.isArray(e.components) ? e.components : [e.components];\n          entityComponents[key] = [...entityComponents[key], ...componentsArray];\n        }\n      }\n      for (const k of Object.keys(entityComponents)) {\n        entities[k].components = entityComponents[k];\n      }\n\n      return Object.values(entities);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all entities for a given room, optionally including their components.\n   * @param {UUID} roomId - The unique identifier of the room to get entities for\n   * @param {boolean} [includeComponents] - Whether to include component data for each entity\n   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities in the room\n   */\n  async getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]> {\n    return this.withDatabase(async () => {\n      const query = this.db\n        .select({\n          entity: entityTable,\n          ...(includeComponents && { components: componentTable }),\n        })\n        .from(participantTable)\n        .leftJoin(\n          entityTable,\n          and(eq(participantTable.entityId, entityTable.id), eq(entityTable.agentId, this.agentId))\n        );\n\n      if (includeComponents) {\n        query.leftJoin(componentTable, eq(componentTable.entityId, entityTable.id));\n      }\n\n      const result = await query.where(eq(participantTable.roomId, roomId));\n\n      // Group components by entity if includeComponents is true\n      const entitiesByIdMap = new Map<UUID, Entity>();\n\n      for (const row of result) {\n        if (!row.entity) continue;\n\n        const entityId = row.entity.id as UUID;\n        if (!entitiesByIdMap.has(entityId)) {\n          const entity: Entity = {\n            ...row.entity,\n            id: entityId,\n            agentId: row.entity.agentId as UUID,\n            metadata: row.entity.metadata as { [key: string]: any },\n            components: includeComponents ? [] : undefined,\n          };\n          entitiesByIdMap.set(entityId, entity);\n        }\n\n        if (includeComponents && row.components) {\n          const entity = entitiesByIdMap.get(entityId);\n          if (entity) {\n            if (!entity.components) {\n              entity.components = [];\n            }\n            entity.components.push(row.components);\n          }\n        }\n      }\n\n      return Array.from(entitiesByIdMap.values());\n    });\n  }\n\n  /**\n   * Asynchronously creates new entities in the database.\n   * @param {Entity[]} entities - The entity objects to be created.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.\n   */\n  async createEntities(entities: Entity[]): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        return await this.db.transaction(async (tx) => {\n          await tx.insert(entityTable).values(entities);\n\n          logger.debug(entities.length, 'Entities created successfully');\n\n          return true;\n        });\n      } catch (error) {\n        logger.error('Error creating entity:', {\n          error: error instanceof Error ? error.message : String(error),\n          entityId: entities[0].id,\n          name: entities[0].metadata?.name,\n        });\n        // trace the error\n        logger.trace(error);\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously ensures an entity exists, creating it if it doesn't\n   * @param entity The entity to ensure exists\n   * @returns Promise resolving to boolean indicating success\n   */\n  protected async ensureEntityExists(entity: Entity): Promise<boolean> {\n    if (!entity.id) {\n      logger.error('Entity ID is required for ensureEntityExists');\n      return false;\n    }\n\n    try {\n      const existingEntities = await this.getEntityByIds([entity.id]);\n\n      if (!existingEntities || !existingEntities.length) {\n        return await this.createEntities([entity]);\n      }\n\n      return true;\n    } catch (error) {\n      logger.error('Error ensuring entity exists:', {\n        error: error instanceof Error ? error.message : String(error),\n        entityId: entity.id,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Asynchronously updates an entity in the database.\n   * @param {Entity} entity - The entity object to be updated.\n   * @returns {Promise<void>} A Promise that resolves when the entity is updated.\n   */\n  async updateEntity(entity: Entity): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db\n        .update(entityTable)\n        .set(entity)\n        .where(and(eq(entityTable.id, entity.id as UUID), eq(entityTable.agentId, entity.agentId)));\n    });\n  }\n\n  async getComponent(\n    entityId: UUID,\n    type: string,\n    worldId?: UUID,\n    sourceEntityId?: UUID\n  ): Promise<Component | null> {\n    return this.withDatabase(async () => {\n      const conditions = [eq(componentTable.entityId, entityId), eq(componentTable.type, type)];\n\n      if (worldId) {\n        conditions.push(eq(componentTable.worldId, worldId));\n      }\n\n      if (sourceEntityId) {\n        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));\n      }\n\n      const result = await this.db\n        .select()\n        .from(componentTable)\n        .where(and(...conditions));\n\n      if (result.length === 0) return null;\n\n      const component = result[0];\n\n      return {\n        ...component,\n        id: component.id as UUID,\n        entityId: component.entityId as UUID,\n        agentId: component.agentId as UUID,\n        roomId: component.roomId as UUID,\n        worldId: (component.worldId ?? '') as UUID,\n        sourceEntityId: (component.sourceEntityId ?? '') as UUID,\n        data: component.data as { [key: string]: any },\n      };\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all components for a given entity, optionally filtered by world and source entity.\n   * @param {UUID} entityId - The unique identifier of the entity to retrieve components for\n   * @param {UUID} [worldId] - Optional world ID to filter components by\n   * @param {UUID} [sourceEntityId] - Optional source entity ID to filter components by\n   * @returns {Promise<Component[]>} A Promise that resolves to an array of components\n   */\n  async getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]> {\n    return this.withDatabase(async () => {\n      const conditions = [eq(componentTable.entityId, entityId)];\n\n      if (worldId) {\n        conditions.push(eq(componentTable.worldId, worldId));\n      }\n\n      if (sourceEntityId) {\n        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));\n      }\n\n      const result = await this.db\n        .select({\n          id: componentTable.id,\n          entityId: componentTable.entityId,\n          type: componentTable.type,\n          data: componentTable.data,\n          worldId: componentTable.worldId,\n          agentId: componentTable.agentId,\n          roomId: componentTable.roomId,\n          sourceEntityId: componentTable.sourceEntityId,\n          createdAt: componentTable.createdAt,\n        })\n        .from(componentTable)\n        .where(and(...conditions));\n\n      if (result.length === 0) return [];\n\n      const components = result.map((component) => ({\n        ...component,\n        id: component.id as UUID,\n        entityId: component.entityId as UUID,\n        agentId: component.agentId as UUID,\n        roomId: component.roomId as UUID,\n        worldId: (component.worldId ?? '') as UUID,\n        sourceEntityId: (component.sourceEntityId ?? '') as UUID,\n        data: component.data as { [key: string]: any },\n      }));\n\n      return components;\n    });\n  }\n\n  /**\n   * Asynchronously creates a new component in the database.\n   * @param {Component} component - The component object to be created.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.\n   */\n  async createComponent(component: Component): Promise<boolean> {\n    return this.withDatabase(async () => {\n      await this.db.insert(componentTable).values(component);\n      return true;\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing component in the database.\n   * @param {Component} component - The component object to be updated.\n   * @returns {Promise<void>} A Promise that resolves when the component is updated.\n   */\n  async updateComponent(component: Component): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db\n        .update(componentTable)\n        .set(component)\n        .where(eq(componentTable.id, component.id));\n    });\n  }\n\n  /**\n   * Asynchronously deletes a component from the database.\n   * @param {UUID} componentId - The unique identifier of the component to delete.\n   * @returns {Promise<void>} A Promise that resolves when the component is deleted.\n   */\n  async deleteComponent(componentId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(componentTable).where(eq(componentTable.id, componentId));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves memories from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving memories.\n   * @param {UUID} params.roomId - The ID of the room to retrieve memories for.\n   * @param {number} [params.count] - The maximum number of memories to retrieve.\n   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.\n   * @param {string} [params.tableName] - The name of the table to retrieve memories from.\n   * @param {number} [params.start] - The start date to retrieve memories from.\n   * @param {number} [params.end] - The end date to retrieve memories from.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async getMemories(params: {\n    entityId?: UUID;\n    agentId?: UUID;\n    count?: number;\n    unique?: boolean;\n    tableName: string;\n    start?: number;\n    end?: number;\n    roomId?: UUID;\n    worldId?: UUID;\n  }): Promise<Memory[]> {\n    const { entityId, agentId, roomId, worldId, tableName, count, unique, start, end } = params;\n\n    if (!tableName) throw new Error('tableName is required');\n    // Allow filtering by any combination now\n    // if (!roomId && !entityId && !agentId && !worldId)\n    //   throw new Error('roomId, entityId, agentId, or worldId is required');\n\n    return this.withDatabase(async () => {\n      const conditions = [eq(memoryTable.type, tableName)];\n\n      if (start) {\n        conditions.push(gte(memoryTable.createdAt, start));\n      }\n\n      if (entityId) {\n        conditions.push(eq(memoryTable.entityId, entityId));\n      }\n\n      if (roomId) {\n        conditions.push(eq(memoryTable.roomId, roomId));\n      }\n\n      // Add worldId condition\n      if (worldId) {\n        conditions.push(eq(memoryTable.worldId, worldId));\n      }\n\n      if (end) {\n        conditions.push(lte(memoryTable.createdAt, end));\n      }\n\n      if (unique) {\n        conditions.push(eq(memoryTable.unique, true));\n      }\n\n      if (agentId) {\n        conditions.push(eq(memoryTable.agentId, agentId));\n      }\n\n      const query = this.db\n        .select({\n          memory: {\n            id: memoryTable.id,\n            type: memoryTable.type,\n            createdAt: memoryTable.createdAt,\n            content: memoryTable.content,\n            entityId: memoryTable.entityId,\n            agentId: memoryTable.agentId,\n            roomId: memoryTable.roomId,\n            unique: memoryTable.unique,\n            metadata: memoryTable.metadata,\n          },\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(memoryTable)\n        .leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id))\n        .where(and(...conditions))\n        .orderBy(desc(memoryTable.createdAt));\n\n      const rows = params.count ? await query.limit(params.count) : await query;\n\n      return rows.map((row) => ({\n        id: row.memory.id as UUID,\n        type: row.memory.type,\n        createdAt: row.memory.createdAt,\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ? Array.from(row.embedding) : undefined,\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves memories from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving memories.\n   * @param {UUID[]} params.roomIds - The IDs of the rooms to retrieve memories for.\n   * @param {string} params.tableName - The name of the table to retrieve memories from.\n   * @param {number} [params.limit] - The maximum number of memories to retrieve.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async getMemoriesByRoomIds(params: {\n    roomIds: UUID[];\n    tableName: string;\n    limit?: number;\n  }): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      if (params.roomIds.length === 0) return [];\n\n      const conditions = [\n        eq(memoryTable.type, params.tableName),\n        inArray(memoryTable.roomId, params.roomIds),\n      ];\n\n      conditions.push(eq(memoryTable.agentId, this.agentId));\n\n      const query = this.db\n        .select({\n          id: memoryTable.id,\n          type: memoryTable.type,\n          createdAt: memoryTable.createdAt,\n          content: memoryTable.content,\n          entityId: memoryTable.entityId,\n          agentId: memoryTable.agentId,\n          roomId: memoryTable.roomId,\n          unique: memoryTable.unique,\n          metadata: memoryTable.metadata,\n        })\n        .from(memoryTable)\n        .where(and(...conditions))\n        .orderBy(desc(memoryTable.createdAt));\n\n      const rows = params.limit ? await query.limit(params.limit) : await query;\n\n      return rows.map((row) => ({\n        id: row.id as UUID,\n        createdAt: row.createdAt,\n        content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,\n        entityId: row.entityId as UUID,\n        agentId: row.agentId as UUID,\n        roomId: row.roomId as UUID,\n        unique: row.unique,\n        metadata: row.metadata,\n      })) as Memory[];\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a memory by its unique identifier.\n   * @param {UUID} id - The unique identifier of the memory to retrieve.\n   * @returns {Promise<Memory | null>} A Promise that resolves to the memory if found, null otherwise.\n   */\n  async getMemoryById(id: UUID): Promise<Memory | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          memory: memoryTable,\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(memoryTable)\n        .leftJoin(embeddingTable, eq(memoryTable.id, embeddingTable.memoryId))\n        .where(eq(memoryTable.id, id))\n        .limit(1);\n\n      if (result.length === 0) return null;\n\n      const row = result[0];\n      return {\n        id: row.memory.id as UUID,\n        createdAt: row.memory.createdAt,\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ?? undefined,\n      };\n    });\n  }\n\n  /**\n   * Asynchronously retrieves memories from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving memories.\n   * @param {UUID[]} params.memoryIds - The IDs of the memories to retrieve.\n   * @param {string} [params.tableName] - The name of the table to retrieve memories from.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async getMemoriesByIds(memoryIds: UUID[], tableName?: string): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      if (memoryIds.length === 0) return [];\n\n      const conditions = [inArray(memoryTable.id, memoryIds)];\n\n      if (tableName) {\n        conditions.push(eq(memoryTable.type, tableName));\n      }\n\n      const rows = await this.db\n        .select({\n          memory: memoryTable,\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(memoryTable)\n        .leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id))\n        .where(and(...conditions))\n        .orderBy(desc(memoryTable.createdAt));\n\n      return rows.map((row) => ({\n        id: row.memory.id as UUID,\n        createdAt: row.memory.createdAt,\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ?? undefined,\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves cached embeddings from the database based on the provided parameters.\n   * @param {Object} opts - The parameters for retrieving cached embeddings.\n   * @param {string} opts.query_table_name - The name of the table to retrieve embeddings from.\n   * @param {number} opts.query_threshold - The threshold for the levenshtein distance.\n   * @param {string} opts.query_input - The input string to search for.\n   * @param {string} opts.query_field_name - The name of the field to retrieve embeddings from.\n   * @param {string} opts.query_field_sub_name - The name of the sub-field to retrieve embeddings from.\n   * @param {number} opts.query_match_count - The maximum number of matches to retrieve.\n   * @returns {Promise<{ embedding: number[]; levenshtein_score: number }[]>} A Promise that resolves to an array of cached embeddings.\n   */\n  async getCachedEmbeddings(opts: {\n    query_table_name: string;\n    query_threshold: number;\n    query_input: string;\n    query_field_name: string;\n    query_field_sub_name: string;\n    query_match_count: number;\n  }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\n    return this.withDatabase(async () => {\n      try {\n        const results = await this.db.execute<{\n          embedding: number[];\n          levenshtein_score: number;\n        }>(sql`\n                    WITH content_text AS (\n                        SELECT\n                            m.id,\n                            COALESCE(\n                                m.content->>${opts.query_field_sub_name},\n                                ''\n                            ) as content_text\n                        FROM memories m\n                        WHERE m.type = ${opts.query_table_name}\n                            AND m.content->>${opts.query_field_sub_name} IS NOT NULL\n                    ),\n                    embedded_text AS (\n                        SELECT\n                            ct.content_text,\n                            COALESCE(\n                                e.dim_384,\n                                e.dim_512,\n                                e.dim_768,\n                                e.dim_1024,\n                                e.dim_1536,\n                                e.dim_3072\n                            ) as embedding\n                        FROM content_text ct\n                        LEFT JOIN embeddings e ON e.memory_id = ct.id\n                        WHERE e.memory_id IS NOT NULL\n                    )\n                    SELECT\n                        embedding,\n                        levenshtein(${opts.query_input}, content_text) as levenshtein_score\n                    FROM embedded_text\n                    WHERE levenshtein(${opts.query_input}, content_text) <= ${opts.query_threshold}\n                    ORDER BY levenshtein_score\n                    LIMIT ${opts.query_match_count}\n                `);\n\n        return results.rows\n          .map((row) => ({\n            embedding: Array.isArray(row.embedding)\n              ? row.embedding\n              : typeof row.embedding === 'string'\n                ? JSON.parse(row.embedding)\n                : [],\n            levenshtein_score: Number(row.levenshtein_score),\n          }))\n          .filter((row) => Array.isArray(row.embedding));\n      } catch (error) {\n        logger.error('Error in getCachedEmbeddings:', {\n          error: error instanceof Error ? error.message : String(error),\n          tableName: opts.query_table_name,\n          fieldName: opts.query_field_name,\n        });\n        if (\n          error instanceof Error &&\n          error.message === 'levenshtein argument exceeds maximum length of 255 characters'\n        ) {\n          return [];\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously logs an event in the database.\n   * @param {Object} params - The parameters for logging an event.\n   * @param {Object} params.body - The body of the event to log.\n   * @param {UUID} params.entityId - The ID of the entity associated with the event.\n   * @param {UUID} params.roomId - The ID of the room associated with the event.\n   * @param {string} params.type - The type of the event to log.\n   * @returns {Promise<void>} A Promise that resolves when the event is logged.\n   */\n  async log(params: {\n    body: { [key: string]: unknown };\n    entityId: UUID;\n    roomId: UUID;\n    type: string;\n  }): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        // Sanitize JSON body to prevent Unicode escape sequence errors\n        const sanitizedBody = this.sanitizeJsonObject(params.body);\n\n        // Serialize to JSON string first for an additional layer of protection\n        // This ensures any problematic characters are properly escaped during JSON serialization\n        const jsonString = JSON.stringify(sanitizedBody);\n\n        await this.db.transaction(async (tx) => {\n          await tx.insert(logTable).values({\n            body: sql`${jsonString}::jsonb`,\n            entityId: params.entityId,\n            roomId: params.roomId,\n            type: params.type,\n          });\n        });\n      } catch (error) {\n        logger.error('Failed to create log entry:', {\n          error: error instanceof Error ? error.message : String(error),\n          type: params.type,\n          roomId: params.roomId,\n          entityId: params.entityId,\n        });\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Sanitizes a JSON object by replacing problematic Unicode escape sequences\n   * that could cause errors during JSON serialization/storage\n   *\n   * @param value - The value to sanitize\n   * @returns The sanitized value\n   */\n  private sanitizeJsonObject(value: unknown): unknown {\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      // Handle multiple cases that can cause PostgreSQL/PgLite JSON parsing errors:\n      // 1. Remove null bytes (U+0000) which are not allowed in PostgreSQL text fields\n      // 2. Escape single backslashes that might be interpreted as escape sequences\n      // 3. Fix broken Unicode escape sequences (\\u not followed by 4 hex digits)\n      return value\n        .replace(/\\u0000/g, '') // Remove null bytes\n        .replace(/\\\\(?![\"\\\\/bfnrtu])/g, '\\\\\\\\') // Escape single backslashes not part of valid escape sequences\n        .replace(/\\\\u(?![0-9a-fA-F]{4})/g, '\\\\\\\\u'); // Fix malformed Unicode escape sequences\n    }\n\n    if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        return value.map((item) => this.sanitizeJsonObject(item));\n      } else {\n        const result: Record<string, unknown> = {};\n        for (const [key, val] of Object.entries(value)) {\n          // Also sanitize object keys\n          const sanitizedKey =\n            typeof key === 'string'\n              ? key.replace(/\\u0000/g, '').replace(/\\\\u(?![0-9a-fA-F]{4})/g, '\\\\\\\\u')\n              : key;\n          result[sanitizedKey] = this.sanitizeJsonObject(val);\n        }\n        return result;\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Asynchronously retrieves logs from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving logs.\n   * @param {UUID} params.entityId - The ID of the entity associated with the logs.\n   * @param {UUID} [params.roomId] - The ID of the room associated with the logs.\n   * @param {string} [params.type] - The type of the logs to retrieve.\n   * @param {number} [params.count] - The maximum number of logs to retrieve.\n   * @param {number} [params.offset] - The offset to retrieve logs from.\n   * @returns {Promise<Log[]>} A Promise that resolves to an array of logs.\n   */\n  async getLogs(params: {\n    entityId: UUID;\n    roomId?: UUID;\n    type?: string;\n    count?: number;\n    offset?: number;\n  }): Promise<Log[]> {\n    const { entityId, roomId, type, count, offset } = params;\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select()\n        .from(logTable)\n        .where(\n          and(\n            eq(logTable.entityId, entityId),\n            roomId ? eq(logTable.roomId, roomId) : undefined,\n            type ? eq(logTable.type, type) : undefined\n          )\n        )\n        .orderBy(desc(logTable.createdAt))\n        .limit(count ?? 10)\n        .offset(offset ?? 0);\n\n      const logs = result.map((log) => ({\n        ...log,\n        id: log.id as UUID,\n        entityId: log.entityId as UUID,\n        roomId: log.roomId as UUID,\n        body: log.body as { [key: string]: unknown },\n        createdAt: new Date(log.createdAt),\n      }));\n\n      if (logs.length === 0) return [];\n\n      return logs;\n    });\n  }\n\n  /**\n   * Asynchronously deletes a log from the database based on the provided parameters.\n   * @param {UUID} logId - The ID of the log to delete.\n   * @returns {Promise<void>} A Promise that resolves when the log is deleted.\n   */\n  async deleteLog(logId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(logTable).where(eq(logTable.id, logId));\n    });\n  }\n\n  /**\n   * Asynchronously searches for memories in the database based on the provided parameters.\n   * @param {Object} params - The parameters for searching for memories.\n   * @param {string} params.tableName - The name of the table to search for memories in.\n   * @param {number[]} params.embedding - The embedding to search for.\n   * @param {number} [params.match_threshold] - The threshold for the cosine distance.\n   * @param {number} [params.count] - The maximum number of memories to retrieve.\n   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.\n   * @param {string} [params.query] - Optional query string for potential reranking.\n   * @param {UUID} [params.roomId] - Optional room ID to filter by.\n   * @param {UUID} [params.worldId] - Optional world ID to filter by.\n   * @param {UUID} [params.entityId] - Optional entity ID to filter by.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async searchMemories(params: {\n    tableName: string;\n    embedding: number[];\n    match_threshold?: number;\n    count?: number;\n    unique?: boolean;\n    query?: string;\n    roomId?: UUID;\n    worldId?: UUID;\n    entityId?: UUID;\n  }): Promise<Memory[]> {\n    return await this.searchMemoriesByEmbedding(params.embedding, {\n      match_threshold: params.match_threshold,\n      count: params.count,\n      // Pass direct scope fields down\n      roomId: params.roomId,\n      worldId: params.worldId,\n      entityId: params.entityId,\n      unique: params.unique,\n      tableName: params.tableName,\n    });\n  }\n\n  /**\n   * Asynchronously searches for memories in the database based on the provided parameters.\n   * @param {number[]} embedding - The embedding to search for.\n   * @param {Object} params - The parameters for searching for memories.\n   * @param {number} [params.match_threshold] - The threshold for the cosine distance.\n   * @param {number} [params.count] - The maximum number of memories to retrieve.\n   * @param {UUID} [params.roomId] - Optional room ID to filter by.\n   * @param {UUID} [params.worldId] - Optional world ID to filter by.\n   * @param {UUID} [params.entityId] - Optional entity ID to filter by.\n   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.\n   * @param {string} [params.tableName] - The name of the table to search for memories in.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async searchMemoriesByEmbedding(\n    embedding: number[],\n    params: {\n      match_threshold?: number;\n      count?: number;\n      roomId?: UUID;\n      worldId?: UUID;\n      entityId?: UUID;\n      unique?: boolean;\n      tableName: string;\n    }\n  ): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      const cleanVector = embedding.map((n) => (Number.isFinite(n) ? Number(n.toFixed(6)) : 0));\n\n      const similarity = sql<number>`1 - (${cosineDistance(\n        embeddingTable[this.embeddingDimension],\n        cleanVector\n      )})`;\n\n      const conditions = [eq(memoryTable.type, params.tableName)];\n\n      if (params.unique) {\n        conditions.push(eq(memoryTable.unique, true));\n      }\n\n      conditions.push(eq(memoryTable.agentId, this.agentId));\n\n      // Add filters based on direct params\n      if (params.roomId) {\n        conditions.push(eq(memoryTable.roomId, params.roomId));\n      }\n      if (params.worldId) {\n        conditions.push(eq(memoryTable.worldId, params.worldId));\n      }\n      if (params.entityId) {\n        conditions.push(eq(memoryTable.entityId, params.entityId));\n      }\n\n      if (params.match_threshold) {\n        conditions.push(gte(similarity, params.match_threshold));\n      }\n\n      const results = await this.db\n        .select({\n          memory: memoryTable,\n          similarity,\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(embeddingTable)\n        .innerJoin(memoryTable, eq(memoryTable.id, embeddingTable.memoryId))\n        .where(and(...conditions))\n        .orderBy(desc(similarity))\n        .limit(params.count ?? 10);\n\n      return results.map((row) => ({\n        id: row.memory.id as UUID,\n        type: row.memory.type,\n        createdAt: row.memory.createdAt,\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        worldId: row.memory.worldId as UUID | undefined, // Include worldId\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ?? undefined,\n        similarity: row.similarity,\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously creates a new memory in the database.\n   * @param {Memory & { metadata?: MemoryMetadata }} memory - The memory object to create.\n   * @param {string} tableName - The name of the table to create the memory in.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created memory.\n   */\n  async createMemory(\n    memory: Memory & { metadata?: MemoryMetadata },\n    tableName: string\n  ): Promise<UUID> {\n    logger.debug('DrizzleAdapter createMemory:', {\n      memoryId: memory.id,\n      embeddingLength: memory.embedding?.length,\n      contentLength: memory.content?.text?.length,\n    });\n\n    const memoryId = memory.id ?? (v4() as UUID);\n\n    const existing = await this.getMemoryById(memoryId);\n    if (existing) {\n      logger.debug('Memory already exists, skipping creation:', {\n        memoryId,\n      });\n      return memoryId;\n    }\n\n    let isUnique = true;\n    if (memory.embedding && Array.isArray(memory.embedding)) {\n      const similarMemories = await this.searchMemoriesByEmbedding(memory.embedding, {\n        tableName,\n        // Use the scope fields from the memory object for similarity check\n        roomId: memory.roomId,\n        worldId: memory.worldId,\n        entityId: memory.entityId,\n        match_threshold: 0.95,\n        count: 1,\n      });\n      isUnique = similarMemories.length === 0;\n    }\n\n    const contentToInsert =\n      typeof memory.content === 'string' ? JSON.parse(memory.content) : memory.content;\n\n    await this.db.transaction(async (tx) => {\n      await tx.insert(memoryTable).values([\n        {\n          id: memoryId,\n          type: tableName,\n          content: sql`${contentToInsert}::jsonb`,\n          metadata: sql`${memory.metadata || {}}::jsonb`,\n          entityId: memory.entityId,\n          roomId: memory.roomId,\n          worldId: memory.worldId, // Include worldId\n          agentId: this.agentId,\n          unique: memory.unique ?? isUnique,\n          createdAt: memory.createdAt,\n        },\n      ]);\n\n      if (memory.embedding && Array.isArray(memory.embedding)) {\n        const embeddingValues: Record<string, unknown> = {\n          id: v4(),\n          memoryId: memoryId,\n          createdAt: memory.createdAt,\n        };\n\n        const cleanVector = memory.embedding.map((n) =>\n          Number.isFinite(n) ? Number(n.toFixed(6)) : 0\n        );\n\n        embeddingValues[this.embeddingDimension] = cleanVector;\n\n        await tx.insert(embeddingTable).values([embeddingValues]);\n      }\n    });\n\n    return memoryId;\n  }\n\n  /**\n   * Updates an existing memory in the database.\n   * @param memory The memory object with updated content and optional embedding\n   * @returns Promise resolving to boolean indicating success\n   */\n  async updateMemory(\n    memory: Partial<Memory> & { id: UUID; metadata?: MemoryMetadata }\n  ): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        logger.debug('Updating memory:', {\n          memoryId: memory.id,\n          hasEmbedding: !!memory.embedding,\n        });\n\n        await this.db.transaction(async (tx) => {\n          // Update memory content if provided\n          if (memory.content) {\n            const contentToUpdate =\n              typeof memory.content === 'string' ? JSON.parse(memory.content) : memory.content;\n\n            await tx\n              .update(memoryTable)\n              .set({\n                content: sql`${contentToUpdate}::jsonb`,\n                ...(memory.metadata && { metadata: sql`${memory.metadata}::jsonb` }),\n              })\n              .where(eq(memoryTable.id, memory.id));\n          } else if (memory.metadata) {\n            // Update only metadata if content is not provided\n            await tx\n              .update(memoryTable)\n              .set({\n                metadata: sql`${memory.metadata}::jsonb`,\n              })\n              .where(eq(memoryTable.id, memory.id));\n          }\n\n          // Update embedding if provided\n          if (memory.embedding && Array.isArray(memory.embedding)) {\n            const cleanVector = memory.embedding.map((n) =>\n              Number.isFinite(n) ? Number(n.toFixed(6)) : 0\n            );\n\n            // Check if embedding exists\n            const existingEmbedding = await tx\n              .select({ id: embeddingTable.id })\n              .from(embeddingTable)\n              .where(eq(embeddingTable.memoryId, memory.id))\n              .limit(1);\n\n            if (existingEmbedding.length > 0) {\n              // Update existing embedding\n              const updateValues: Record<string, unknown> = {};\n              updateValues[this.embeddingDimension] = cleanVector;\n\n              await tx\n                .update(embeddingTable)\n                .set(updateValues)\n                .where(eq(embeddingTable.memoryId, memory.id));\n            } else {\n              // Create new embedding\n              const embeddingValues: Record<string, unknown> = {\n                id: v4(),\n                memoryId: memory.id,\n                createdAt: Date.now(),\n              };\n              embeddingValues[this.embeddingDimension] = cleanVector;\n\n              await tx.insert(embeddingTable).values([embeddingValues]);\n            }\n          }\n        });\n\n        logger.debug('Memory updated successfully:', {\n          memoryId: memory.id,\n        });\n        return true;\n      } catch (error) {\n        logger.error('Error updating memory:', {\n          error: error instanceof Error ? error.message : String(error),\n          memoryId: memory.id,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously deletes a memory from the database based on the provided parameters.\n   * @param {UUID} memoryId - The ID of the memory to delete.\n   * @returns {Promise<void>} A Promise that resolves when the memory is deleted.\n   */\n  async deleteMemory(memoryId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        // See if there are any fragments that we need to delete\n        await this.deleteMemoryFragments(tx, memoryId);\n\n        // Then delete the embedding for the main memory\n        await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));\n\n        // Finally delete the memory itself\n        await tx.delete(memoryTable).where(eq(memoryTable.id, memoryId));\n      });\n\n      logger.debug('Memory and related fragments removed successfully:', {\n        memoryId,\n      });\n    });\n  }\n\n  /**\n   * Deletes all memory fragments that reference a specific document memory\n   * @param tx The database transaction\n   * @param documentId The UUID of the document memory whose fragments should be deleted\n   * @private\n   */\n  private async deleteMemoryFragments(tx: DrizzleDatabase, documentId: UUID): Promise<void> {\n    const fragmentsToDelete = await this.getMemoryFragments(tx, documentId);\n\n    if (fragmentsToDelete.length > 0) {\n      const fragmentIds = fragmentsToDelete.map((f) => f.id) as UUID[];\n\n      // Delete embeddings for fragments\n      await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, fragmentIds));\n\n      // Delete the fragments\n      await tx.delete(memoryTable).where(inArray(memoryTable.id, fragmentIds));\n\n      logger.debug('Deleted related fragments:', {\n        documentId,\n        fragmentCount: fragmentsToDelete.length,\n      });\n    }\n  }\n\n  /**\n   * Retrieves all memory fragments that reference a specific document memory\n   * @param tx The database transaction\n   * @param documentId The UUID of the document memory whose fragments should be retrieved\n   * @returns An array of memory fragments\n   * @private\n   */\n  private async getMemoryFragments(tx: DrizzleDatabase, documentId: UUID): Promise<{ id: UUID }[]> {\n    const fragments = await tx\n      .select({ id: memoryTable.id })\n      .from(memoryTable)\n      .where(\n        and(\n          eq(memoryTable.agentId, this.agentId),\n          sql`${memoryTable.metadata}->>'documentId' = ${documentId}`\n        )\n      );\n\n    return fragments.map((f) => ({ id: f.id as UUID }));\n  }\n\n  /**\n   * Asynchronously deletes all memories from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to delete memories from.\n   * @param {string} tableName - The name of the table to delete memories from.\n   * @returns {Promise<void>} A Promise that resolves when the memories are deleted.\n   */\n  async deleteAllMemories(roomId: UUID, tableName: string): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        // 1) fetch all memory IDs for this room + table\n        const rows = await tx\n          .select({ id: memoryTable.id })\n          .from(memoryTable)\n          .where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));\n\n        const ids = rows.map((r) => r.id);\n        logger.debug('[deleteAllMemories] memory IDs to delete:', { roomId, tableName, ids });\n\n        if (ids.length === 0) {\n          return;\n        }\n\n        // 2) delete any fragments for \"document\" memories & their embeddings\n        await Promise.all(\n          ids.map(async (memoryId) => {\n            await this.deleteMemoryFragments(tx, memoryId);\n            await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));\n          })\n        );\n\n        // 3) delete the memories themselves\n        await tx\n          .delete(memoryTable)\n          .where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));\n      });\n\n      logger.debug('All memories removed successfully:', { roomId, tableName });\n    });\n  }\n\n  /**\n   * Asynchronously counts the number of memories in the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to count memories in.\n   * @param {boolean} [unique] - Whether to count unique memories only.\n   * @param {string} [tableName] - The name of the table to count memories in.\n   * @returns {Promise<number>} A Promise that resolves to the number of memories.\n   */\n  async countMemories(roomId: UUID, unique = true, tableName = ''): Promise<number> {\n    if (!tableName) throw new Error('tableName is required');\n\n    return this.withDatabase(async () => {\n      const conditions = [eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)];\n\n      if (unique) {\n        conditions.push(eq(memoryTable.unique, true));\n      }\n\n      const result = await this.db\n        .select({ count: sql<number>`count(*)` })\n        .from(memoryTable)\n        .where(and(...conditions));\n\n      return Number(result[0]?.count ?? 0);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves rooms from the database based on the provided parameters.\n   * @param {UUID[]} roomIds - The IDs of the rooms to retrieve.\n   * @returns {Promise<Room[] | null>} A Promise that resolves to the rooms if found, null otherwise.\n   */\n  async getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          id: roomTable.id,\n          name: roomTable.name, // Added name\n          channelId: roomTable.channelId,\n          agentId: roomTable.agentId,\n          serverId: roomTable.serverId,\n          worldId: roomTable.worldId,\n          type: roomTable.type,\n          source: roomTable.source,\n          metadata: roomTable.metadata, // Added metadata\n        })\n        .from(roomTable)\n        .where(and(inArray(roomTable.id, roomIds), eq(roomTable.agentId, this.agentId)));\n\n      // Map the result to properly typed Room objects\n      const rooms = result.map((room) => ({\n        ...room,\n        id: room.id as UUID,\n        name: room.name ?? undefined,\n        agentId: room.agentId as UUID,\n        serverId: room.serverId as UUID,\n        worldId: room.worldId as UUID,\n        channelId: room.channelId as UUID,\n        type: room.type as ChannelType,\n        metadata: room.metadata as RoomMetadata,\n      }));\n\n      return rooms;\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all rooms from the database based on the provided parameters.\n   * @param {UUID} worldId - The ID of the world to retrieve rooms from.\n   * @returns {Promise<Room[]>} A Promise that resolves to an array of rooms.\n   */\n  async getRoomsByWorld(worldId: UUID): Promise<Room[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db.select().from(roomTable).where(eq(roomTable.worldId, worldId));\n      const rooms = result.map((room) => ({\n        ...room,\n        id: room.id as UUID,\n        name: room.name ?? undefined,\n        agentId: room.agentId as UUID,\n        serverId: room.serverId as UUID,\n        worldId: room.worldId as UUID,\n        channelId: room.channelId as UUID,\n        type: room.type as ChannelType,\n        metadata: room.metadata as RoomMetadata,\n      }));\n      return rooms;\n    });\n  }\n\n  /**\n   * Asynchronously updates a room in the database based on the provided parameters.\n   * @param {Room} room - The room object to update.\n   * @returns {Promise<void>} A Promise that resolves when the room is updated.\n   */\n  async updateRoom(room: Room): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db\n        .update(roomTable)\n        .set({ ...room, agentId: this.agentId })\n        .where(eq(roomTable.id, room.id));\n    });\n  }\n\n  /**\n   * Asynchronously creates a new room in the database based on the provided parameters.\n   * @param {Room} room - The room object to create.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created room.\n   */\n  async createRooms(rooms: Room[]): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const roomsWithIds = rooms.map((room) => ({\n        ...room,\n        id: room.id || v4(), // ensure each room has a unique ID\n      }));\n\n      const insertedRooms = await this.db\n        .insert(roomTable)\n        .values(roomsWithIds)\n        .onConflictDoNothing()\n        .returning();\n      const insertedIds = insertedRooms.map((r) => r.id as UUID);\n      return insertedIds;\n    });\n  }\n\n  /**\n   * Asynchronously deletes a room from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to delete.\n   * @returns {Promise<void>} A Promise that resolves when the room is deleted.\n   */\n  async deleteRoom(roomId: UUID): Promise<void> {\n    if (!roomId) throw new Error('Room ID is required');\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        await tx.delete(roomTable).where(eq(roomTable.id, roomId));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all rooms for a participant from the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to retrieve rooms for.\n   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.\n   */\n  async getRoomsForParticipant(entityId: UUID): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({ roomId: participantTable.roomId })\n        .from(participantTable)\n        .innerJoin(roomTable, eq(participantTable.roomId, roomTable.id))\n        .where(and(eq(participantTable.entityId, entityId), eq(roomTable.agentId, this.agentId)));\n\n      return result.map((row) => row.roomId as UUID);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all rooms for a list of participants from the database based on the provided parameters.\n   * @param {UUID[]} entityIds - The IDs of the entities to retrieve rooms for.\n   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.\n   */\n  async getRoomsForParticipants(entityIds: UUID[]): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .selectDistinct({ roomId: participantTable.roomId })\n        .from(participantTable)\n        .innerJoin(roomTable, eq(participantTable.roomId, roomTable.id))\n        .where(\n          and(inArray(participantTable.entityId, entityIds), eq(roomTable.agentId, this.agentId))\n        );\n\n      return result.map((row) => row.roomId as UUID);\n    });\n  }\n\n  /**\n   * Asynchronously adds a participant to a room in the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to add to the room.\n   * @param {UUID} roomId - The ID of the room to add the entity to.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was added successfully.\n   */\n  async addParticipant(entityId: UUID, roomId: UUID): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db\n          .insert(participantTable)\n          .values({\n            entityId,\n            roomId,\n            agentId: this.agentId,\n          })\n          .onConflictDoNothing();\n        return true;\n      } catch (error) {\n        logger.error('Error adding participant', {\n          error: error instanceof Error ? error.message : String(error),\n          entityId,\n          roomId,\n          agentId: this.agentId,\n        });\n        return false;\n      }\n    });\n  }\n\n  async addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        const values = entityIds.map((id) => ({\n          entityId: id,\n          roomId,\n          agentId: this.agentId,\n        }));\n        await this.db.insert(participantTable).values(values).onConflictDoNothing().execute();\n        logger.debug(entityIds.length, 'Entities linked successfully');\n        return true;\n      } catch (error) {\n        logger.error('Error adding participants', {\n          error: error instanceof Error ? error.message : String(error),\n          entityIdSample: entityIds[0],\n          roomId,\n          agentId: this.agentId,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously removes a participant from a room in the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to remove from the room.\n   * @param {UUID} roomId - The ID of the room to remove the entity from.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was removed successfully.\n   */\n  async removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        const result = await this.db.transaction(async (tx) => {\n          return await tx\n            .delete(participantTable)\n            .where(\n              and(eq(participantTable.entityId, entityId), eq(participantTable.roomId, roomId))\n            )\n            .returning();\n        });\n\n        const removed = result.length > 0;\n        logger.debug(`Participant ${removed ? 'removed' : 'not found'}:`, {\n          entityId,\n          roomId,\n          removed,\n        });\n\n        return removed;\n      } catch (error) {\n        logger.error('Failed to remove participant:', {\n          error: error instanceof Error ? error.message : String(error),\n          entityId,\n          roomId,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all participants for an entity from the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to retrieve participants for.\n   * @returns {Promise<Participant[]>} A Promise that resolves to an array of participants.\n   */\n  async getParticipantsForEntity(entityId: UUID): Promise<Participant[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          id: participantTable.id,\n          entityId: participantTable.entityId,\n          roomId: participantTable.roomId,\n        })\n        .from(participantTable)\n        .where(eq(participantTable.entityId, entityId));\n\n      const entities = await this.getEntityByIds([entityId]);\n\n      if (!entities || !entities.length) {\n        return [];\n      }\n\n      return result.map((row) => ({\n        id: row.id as UUID,\n        entity: entities[0],\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all participants for a room from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to retrieve participants for.\n   * @returns {Promise<UUID[]>} A Promise that resolves to an array of entity IDs.\n   */\n  async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({ entityId: participantTable.entityId })\n        .from(participantTable)\n        .where(eq(participantTable.roomId, roomId));\n\n      return result.map((row) => row.entityId as UUID);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves the user state for a participant in a room from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to retrieve the participant's user state for.\n   * @param {UUID} entityId - The ID of the entity to retrieve the user state for.\n   * @returns {Promise<\"FOLLOWED\" | \"MUTED\" | null>} A Promise that resolves to the participant's user state.\n   */\n  async getParticipantUserState(\n    roomId: UUID,\n    entityId: UUID\n  ): Promise<'FOLLOWED' | 'MUTED' | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({ roomState: participantTable.roomState })\n        .from(participantTable)\n        .where(\n          and(\n            eq(participantTable.roomId, roomId),\n            eq(participantTable.entityId, entityId),\n            eq(participantTable.agentId, this.agentId)\n          )\n        )\n        .limit(1);\n\n      return (result[0]?.roomState as 'FOLLOWED' | 'MUTED' | null) ?? null;\n    });\n  }\n\n  /**\n   * Asynchronously sets the user state for a participant in a room in the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to set the participant's user state for.\n   * @param {UUID} entityId - The ID of the entity to set the user state for.\n   * @param {string} state - The state to set the participant's user state to.\n   * @returns {Promise<void>} A Promise that resolves when the participant's user state is set.\n   */\n  async setParticipantUserState(\n    roomId: UUID,\n    entityId: UUID,\n    state: 'FOLLOWED' | 'MUTED' | null\n  ): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.transaction(async (tx) => {\n          await tx\n            .update(participantTable)\n            .set({ roomState: state })\n            .where(\n              and(\n                eq(participantTable.roomId, roomId),\n                eq(participantTable.entityId, entityId),\n                eq(participantTable.agentId, this.agentId)\n              )\n            );\n        });\n      } catch (error) {\n        logger.error('Failed to set participant user state:', {\n          roomId,\n          entityId,\n          state,\n          error: error instanceof Error ? error.message : String(error),\n        });\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously creates a new relationship in the database based on the provided parameters.\n   * @param {Object} params - The parameters for creating a new relationship.\n   * @param {UUID} params.sourceEntityId - The ID of the source entity.\n   * @param {UUID} params.targetEntityId - The ID of the target entity.\n   * @param {string[]} [params.tags] - The tags for the relationship.\n   * @param {Object} [params.metadata] - The metadata for the relationship.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the relationship was created successfully.\n   */\n  async createRelationship(params: {\n    sourceEntityId: UUID;\n    targetEntityId: UUID;\n    tags?: string[];\n    metadata?: { [key: string]: unknown };\n  }): Promise<boolean> {\n    return this.withDatabase(async () => {\n      const id = v4();\n      const saveParams = {\n        id,\n        sourceEntityId: params.sourceEntityId,\n        targetEntityId: params.targetEntityId,\n        agentId: this.agentId,\n        tags: params.tags || [],\n        metadata: params.metadata || {},\n      };\n      try {\n        await this.db.insert(relationshipTable).values(saveParams);\n        return true;\n      } catch (error) {\n        logger.error('Error creating relationship:', {\n          error: error instanceof Error ? error.message : String(error),\n          saveParams,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing relationship in the database based on the provided parameters.\n   * @param {Relationship} relationship - The relationship object to update.\n   * @returns {Promise<void>} A Promise that resolves when the relationship is updated.\n   */\n  async updateRelationship(relationship: Relationship): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db\n          .update(relationshipTable)\n          .set({\n            tags: relationship.tags || [],\n            metadata: relationship.metadata || {},\n          })\n          .where(eq(relationshipTable.id, relationship.id));\n      } catch (error) {\n        logger.error('Error updating relationship:', {\n          error: error instanceof Error ? error.message : String(error),\n          relationship,\n        });\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a relationship from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving a relationship.\n   * @param {UUID} params.sourceEntityId - The ID of the source entity.\n   * @param {UUID} params.targetEntityId - The ID of the target entity.\n   * @returns {Promise<Relationship | null>} A Promise that resolves to the relationship if found, null otherwise.\n   */\n  async getRelationship(params: {\n    sourceEntityId: UUID;\n    targetEntityId: UUID;\n  }): Promise<Relationship | null> {\n    return this.withDatabase(async () => {\n      try {\n        const result = await this.db\n          .select()\n          .from(relationshipTable)\n          .where(\n            and(\n              eq(relationshipTable.sourceEntityId, params.sourceEntityId),\n              eq(relationshipTable.targetEntityId, params.targetEntityId),\n              eq(relationshipTable.agentId, this.agentId)\n            )\n          )\n          .limit(1);\n\n        if (result.length === 0) {\n          return null;\n        }\n\n        return {\n          id: result[0].id as UUID,\n          sourceEntityId: result[0].sourceEntityId as UUID,\n          targetEntityId: result[0].targetEntityId as UUID,\n          agentId: result[0].agentId as UUID,\n          tags: result[0].tags || [],\n          metadata: result[0].metadata || {},\n          createdAt: result[0].createdAt?.toString(),\n        };\n      } catch (error) {\n        logger.error('Error getting relationship:', {\n          error: error instanceof Error ? error.message : String(error),\n          params,\n        });\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all relationships from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving relationships.\n   * @param {UUID} params.entityId - The ID of the entity to retrieve relationships for.\n   * @param {string[]} [params.tags] - The tags to filter relationships by.\n   * @returns {Promise<Relationship[]>} A Promise that resolves to an array of relationships.\n   */\n  async getRelationships(params: { entityId: UUID; tags?: string[] }): Promise<Relationship[]> {\n    return this.withDatabase(async () => {\n      const conditions = [\n        or(\n          eq(relationshipTable.sourceEntityId, params.entityId),\n          eq(relationshipTable.targetEntityId, params.entityId)\n        ),\n        eq(relationshipTable.agentId, this.agentId),\n        ...(params.tags && params.tags.length > 0\n          ? [\n              sql`${relationshipTable.tags} @> ARRAY[${sql.raw(\n                params.tags.map((tag) => `'${tag.replace(/'/g, \"''\")}'`).join(', ')\n              )}]::text[]`,\n            ]\n          : []),\n      ];\n\n      const results = await this.db\n        .select()\n        .from(relationshipTable)\n        .where(and(...conditions));\n\n      return results.map((row) => ({\n        id: row.id as UUID,\n        sourceEntityId: row.sourceEntityId as UUID,\n        targetEntityId: row.targetEntityId as UUID,\n        agentId: row.agentId as UUID,\n        tags: row.tags || [],\n        metadata: row.metadata || {},\n        createdAt: row.createdAt?.toString(),\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a cache value from the database based on the provided key.\n   * @param {string} key - The key to retrieve the cache value for.\n   * @returns {Promise<T | undefined>} A Promise that resolves to the cache value if found, undefined otherwise.\n   */\n  async getCache<T>(key: string): Promise<T | undefined> {\n    return this.withDatabase(async () => {\n      try {\n        const result = await this.db\n          .select()\n          .from(cacheTable)\n          .where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));\n\n        return result[0]?.value as T | undefined;\n      } catch (error) {\n        logger.error('Error fetching cache', {\n          error: error instanceof Error ? error.message : String(error),\n          key: key,\n          agentId: this.agentId,\n        });\n        return undefined;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously sets a cache value in the database based on the provided key and value.\n   * @param {string} key - The key to set the cache value for.\n   * @param {T} value - The value to set in the cache.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was set successfully.\n   */\n  async setCache<T>(key: string, value: T): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.transaction(async (tx) => {\n          await tx\n            .insert(cacheTable)\n            .values({\n              key: key,\n              agentId: this.agentId,\n              value: value,\n            })\n            .onConflictDoUpdate({\n              target: [cacheTable.key, cacheTable.agentId],\n              set: {\n                value: value,\n              },\n            });\n        });\n        return true;\n      } catch (error) {\n        logger.error('Error setting cache', {\n          error: error instanceof Error ? error.message : String(error),\n          key: key,\n          agentId: this.agentId,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously deletes a cache value from the database based on the provided key.\n   * @param {string} key - The key to delete the cache value for.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was deleted successfully.\n   */\n  async deleteCache(key: string): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.transaction(async (tx) => {\n          await tx\n            .delete(cacheTable)\n            .where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));\n        });\n        return true;\n      } catch (error) {\n        logger.error('Error deleting cache', {\n          error: error instanceof Error ? error.message : String(error),\n          key: key,\n          agentId: this.agentId,\n        });\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously creates a new world in the database based on the provided parameters.\n   * @param {World} world - The world object to create.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created world.\n   */\n  async createWorld(world: World): Promise<UUID> {\n    return this.withDatabase(async () => {\n      const newWorldId = world.id || v4();\n      await this.db.insert(worldTable).values({\n        ...world,\n        id: newWorldId,\n        name: world.name || '',\n      });\n      return newWorldId;\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a world from the database based on the provided parameters.\n   * @param {UUID} id - The ID of the world to retrieve.\n   * @returns {Promise<World | null>} A Promise that resolves to the world if found, null otherwise.\n   */\n  async getWorld(id: UUID): Promise<World | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db.select().from(worldTable).where(eq(worldTable.id, id));\n      return result[0] as World | null;\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all worlds from the database based on the provided parameters.\n   * @returns {Promise<World[]>} A Promise that resolves to an array of worlds.\n   */\n  async getAllWorlds(): Promise<World[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select()\n        .from(worldTable)\n        .where(eq(worldTable.agentId, this.agentId));\n      return result as World[];\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing world in the database based on the provided parameters.\n   * @param {World} world - The world object to update.\n   * @returns {Promise<void>} A Promise that resolves when the world is updated.\n   */\n  async updateWorld(world: World): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.update(worldTable).set(world).where(eq(worldTable.id, world.id));\n    });\n  }\n\n  /**\n   * Asynchronously removes a world from the database based on the provided parameters.\n   * @param {UUID} id - The ID of the world to remove.\n   * @returns {Promise<void>} A Promise that resolves when the world is removed.\n   */\n  async removeWorld(id: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(worldTable).where(eq(worldTable.id, id));\n    });\n  }\n\n  /**\n   * Asynchronously creates a new task in the database based on the provided parameters.\n   * @param {Task} task - The task object to create.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created task.\n   */\n  async createTask(task: Task): Promise<UUID> {\n    if (!task.worldId) {\n      throw new Error('worldId is required');\n    }\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const now = new Date();\n        const metadata = task.metadata || {};\n\n        const values = {\n          id: task.id as UUID,\n          name: task.name,\n          description: task.description,\n          roomId: task.roomId as UUID,\n          worldId: task.worldId as UUID,\n          tags: task.tags,\n          metadata: metadata,\n          createdAt: now,\n          updatedAt: now,\n          agentId: this.agentId as UUID,\n        };\n        const result = await this.db.insert(taskTable).values(values).returning();\n\n        return result[0].id as UUID;\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves tasks based on specified parameters.\n   * @param params Object containing optional roomId, tags, and entityId to filter tasks\n   * @returns Promise resolving to an array of Task objects\n   */\n  async getTasks(params: {\n    roomId?: UUID;\n    tags?: string[];\n    entityId?: UUID; // Added entityId parameter\n  }): Promise<Task[]> {\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const result = await this.db\n          .select()\n          .from(taskTable)\n          .where(\n            and(\n              eq(taskTable.agentId, this.agentId),\n              ...(params.roomId ? [eq(taskTable.roomId, params.roomId)] : []),\n              ...(params.tags && params.tags.length > 0\n                ? [\n                    sql`${taskTable.tags} @> ARRAY[${sql.raw(\n                      params.tags.map((t) => `'${t.replace(/'/g, \"''\")}'`).join(', ')\n                    )}]::text[]`,\n                  ]\n                : [])\n            )\n          );\n\n        return result.map((row) => ({\n          id: row.id as UUID,\n          name: row.name,\n          description: row.description ?? '',\n          roomId: row.roomId as UUID,\n          worldId: row.worldId as UUID,\n          tags: row.tags || [],\n          metadata: row.metadata as TaskMetadata,\n        }));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a specific task by its name.\n   * @param name The name of the task to retrieve\n   * @returns Promise resolving to the Task object if found, null otherwise\n   */\n  async getTasksByName(name: string): Promise<Task[]> {\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const result = await this.db\n          .select()\n          .from(taskTable)\n          .where(and(eq(taskTable.name, name), eq(taskTable.agentId, this.agentId)));\n\n        return result.map((row) => ({\n          id: row.id as UUID,\n          name: row.name,\n          description: row.description ?? '',\n          roomId: row.roomId as UUID,\n          worldId: row.worldId as UUID,\n          tags: row.tags || [],\n          metadata: (row.metadata || {}) as TaskMetadata,\n        }));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a specific task by its ID.\n   * @param id The UUID of the task to retrieve\n   * @returns Promise resolving to the Task object if found, null otherwise\n   */\n  async getTask(id: UUID): Promise<Task | null> {\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const result = await this.db\n          .select()\n          .from(taskTable)\n          .where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)))\n          .limit(1);\n\n        if (result.length === 0) {\n          return null;\n        }\n\n        const row = result[0];\n        return {\n          id: row.id as UUID,\n          name: row.name,\n          description: row.description ?? '',\n          roomId: row.roomId as UUID,\n          worldId: row.worldId as UUID,\n          tags: row.tags || [],\n          metadata: (row.metadata || {}) as TaskMetadata,\n        };\n      });\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing task in the database.\n   * @param id The UUID of the task to update\n   * @param task Partial Task object containing the fields to update\n   * @returns Promise resolving when the update is complete\n   */\n  async updateTask(id: UUID, task: Partial<Task>): Promise<void> {\n    await this.withRetry(async () => {\n      await this.withDatabase(async () => {\n        const updateValues: Partial<Task> = {};\n\n        // Add fields to update if they exist in the partial task object\n        if (task.name !== undefined) updateValues.name = task.name;\n        if (task.description !== undefined) updateValues.description = task.description;\n        if (task.roomId !== undefined) updateValues.roomId = task.roomId;\n        if (task.worldId !== undefined) updateValues.worldId = task.worldId;\n        if (task.tags !== undefined) updateValues.tags = task.tags;\n\n        task.updatedAt = Date.now();\n\n        // Handle metadata updates\n        if (task.metadata) {\n          // Get current task to merge metadata\n          const currentTask = await this.getTask(id);\n          if (currentTask) {\n            const currentMetadata = currentTask.metadata || {};\n            const newMetadata = {\n              ...currentMetadata,\n              ...task.metadata,\n            };\n            updateValues.metadata = newMetadata;\n          } else {\n            updateValues.metadata = {\n              ...task.metadata,\n            };\n          }\n        }\n\n        await this.db\n          .update(taskTable)\n          // createdAt is hella borked, number / Date\n          .set(updateValues as any)\n          .where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously deletes a task from the database.\n   * @param id The UUID of the task to delete\n   * @returns Promise resolving when the deletion is complete\n   */\n  async deleteTask(id: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(taskTable).where(eq(taskTable.id, id));\n    });\n  }\n\n  async getMemoriesByWorldId(params: {\n    worldId: UUID;\n    count?: number;\n    tableName?: string;\n  }): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      // First, get all rooms for the given worldId\n      const rooms = await this.db\n        .select({ id: roomTable.id })\n        .from(roomTable)\n        .where(and(eq(roomTable.worldId, params.worldId), eq(roomTable.agentId, this.agentId)));\n\n      if (rooms.length === 0) {\n        return [];\n      }\n\n      const roomIds = rooms.map((room) => room.id as UUID);\n\n      const memories = await this.getMemoriesByRoomIds({\n        roomIds,\n        tableName: params.tableName || 'messages',\n        limit: params.count,\n      });\n\n      return memories;\n    });\n  }\n\n  async deleteRoomsByWorldId(worldId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      const rooms = await this.db\n        .select({ id: roomTable.id })\n        .from(roomTable)\n        .where(and(eq(roomTable.worldId, worldId), eq(roomTable.agentId, this.agentId)));\n\n      if (rooms.length === 0) {\n        logger.debug(\n          `No rooms found for worldId ${worldId} and agentId ${this.agentId} to delete.`\n        );\n        return;\n      }\n\n      const roomIds = rooms.map((room) => room.id as UUID);\n\n      if (roomIds.length > 0) {\n        await this.db.delete(logTable).where(inArray(logTable.roomId, roomIds));\n        logger.debug(`Deleted logs for ${roomIds.length} rooms in world ${worldId}.`);\n\n        await this.db.delete(participantTable).where(inArray(participantTable.roomId, roomIds));\n        logger.debug(`Deleted participants for ${roomIds.length} rooms in world ${worldId}.`);\n\n        const memoriesInRooms = await this.db\n          .select({ id: memoryTable.id })\n          .from(memoryTable)\n          .where(inArray(memoryTable.roomId, roomIds));\n        const memoryIdsInRooms = memoriesInRooms.map((m) => m.id as UUID);\n\n        if (memoryIdsInRooms.length > 0) {\n          await this.db\n            .delete(embeddingTable)\n            .where(inArray(embeddingTable.memoryId, memoryIdsInRooms));\n          logger.debug(\n            `Deleted embeddings for ${memoryIdsInRooms.length} memories in world ${worldId}.`\n          );\n          await this.db.delete(memoryTable).where(inArray(memoryTable.id, memoryIdsInRooms));\n          logger.debug(`Deleted ${memoryIdsInRooms.length} memories in world ${worldId}.`);\n        }\n\n        await this.db.delete(roomTable).where(inArray(roomTable.id, roomIds));\n        logger.debug(`Deleted ${roomIds.length} rooms for worldId ${worldId}.`);\n      }\n    });\n  }\n}\n","import { sql } from 'drizzle-orm';\nimport { check, foreignKey, index, pgTable, uuid, vector } from 'drizzle-orm/pg-core';\nimport { VECTOR_DIMS } from '@elizaos/core';\nimport { memoryTable } from './memory';\nimport { numberTimestamp } from './types';\n\nexport const DIMENSION_MAP = {\n  [VECTOR_DIMS.SMALL]: 'dim384',\n  [VECTOR_DIMS.MEDIUM]: 'dim512',\n  [VECTOR_DIMS.LARGE]: 'dim768',\n  [VECTOR_DIMS.XL]: 'dim1024',\n  [VECTOR_DIMS.XXL]: 'dim1536',\n  [VECTOR_DIMS.XXXL]: 'dim3072',\n} as const;\n\n/**\n * Definition of the embeddings table in the database.\n * Contains columns for ID, Memory ID, Creation Timestamp, and multiple vector dimensions.\n */\nexport const embeddingTable = pgTable(\n  'embeddings',\n  {\n    id: uuid('id').primaryKey().defaultRandom().notNull(),\n    memoryId: uuid('memory_id').references(() => memoryTable.id),\n    createdAt: numberTimestamp('created_at')\n      .default(sql`now()`)\n      .notNull(),\n    dim384: vector('dim_384', { dimensions: VECTOR_DIMS.SMALL }),\n    dim512: vector('dim_512', { dimensions: VECTOR_DIMS.MEDIUM }),\n    dim768: vector('dim_768', { dimensions: VECTOR_DIMS.LARGE }),\n    dim1024: vector('dim_1024', { dimensions: VECTOR_DIMS.XL }),\n    dim1536: vector('dim_1536', { dimensions: VECTOR_DIMS.XXL }),\n    dim3072: vector('dim_3072', { dimensions: VECTOR_DIMS.XXXL }),\n  },\n  (table) => [\n    check('embedding_source_check', sql`\"memory_id\" IS NOT NULL`),\n    index('idx_embedding_memory').on(table.memoryId),\n    foreignKey({\n      name: 'fk_embedding_memory',\n      columns: [table.memoryId],\n      foreignColumns: [memoryTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n\n/**\n * Defines the possible values for the Embedding Dimension Column.\n * It can be \"dim384\", \"dim512\", \"dim768\", \"dim1024\", \"dim1536\", or \"dim3072\".\n */\nexport type EmbeddingDimensionColumn =\n  | 'dim384'\n  | 'dim512'\n  | 'dim768'\n  | 'dim1024'\n  | 'dim1536'\n  | 'dim3072';\n\n/**\n * Retrieve the type of a specific column in the EmbeddingTable based on the EmbeddingDimensionColumn key.\n */\nexport type EmbeddingTableColumn = (typeof embeddingTable._.columns)[EmbeddingDimensionColumn];\n","import { relations, sql } from 'drizzle-orm';\nimport {\n  boolean,\n  check,\n  foreignKey,\n  index,\n  jsonb,\n  pgTable,\n  text,\n  unique,\n  uuid,\n  vector,\n} from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { embeddingTable } from './embedding';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\nimport { worldTable } from './world';\nimport { numberTimestamp } from './types';\n\n/**\n * Definition of the memory table in the database.\n *\n * @param {string} tableName - The name of the table.\n * @param {object} columns - An object containing the column definitions.\n * @param {function} indexes - A function that defines the indexes for the table.\n * @returns {object} - The memory table object.\n */\nexport const memoryTable = pgTable(\n  'memories',\n  {\n    id: uuid('id').primaryKey().notNull(),\n    type: text('type').notNull(),\n    createdAt: numberTimestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n    content: jsonb('content').notNull(),\n    entityId: uuid('entityId').references(() => entityTable.id, {\n      onDelete: 'cascade',\n    }),\n    agentId: uuid('agentId')\n      .references(() => agentTable.id, {\n        onDelete: 'cascade',\n      })\n      .notNull(),\n    roomId: uuid('roomId').references(() => roomTable.id, {\n      onDelete: 'cascade',\n    }),\n    worldId: uuid('worldId'),\n    // .references(() => worldTable.id, {\n    //   onDelete: 'set null',\n    // }),\n    unique: boolean('unique').default(true).notNull(),\n    metadata: jsonb('metadata').default({}).notNull(),\n  },\n  (table) => [\n    index('idx_memories_type_room').on(table.type, table.roomId),\n    index('idx_memories_world_id').on(table.worldId),\n    foreignKey({\n      name: 'fk_room',\n      columns: [table.roomId],\n      foreignColumns: [roomTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user',\n      columns: [table.entityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_agent',\n      columns: [table.agentId],\n      foreignColumns: [agentTable.id],\n    }).onDelete('cascade'),\n    // foreignKey({\n    //   name: 'fk_world',\n    //   columns: [table.worldId],\n    //   foreignColumns: [worldTable.id],\n    // }).onDelete('set null'),\n    index('idx_memories_metadata_type').on(sql`((metadata->>'type'))`),\n    index('idx_memories_document_id').on(sql`((metadata->>'documentId'))`),\n    index('idx_fragments_order').on(\n      sql`((metadata->>'documentId'))`,\n      sql`((metadata->>'position'))`\n    ),\n    check(\n      'fragment_metadata_check',\n      sql`\n            CASE \n                WHEN metadata->>'type' = 'fragment' THEN\n                    metadata ? 'documentId' AND \n                    metadata ? 'position'\n                ELSE true\n            END\n        `\n    ),\n    check(\n      'document_metadata_check',\n      sql`\n            CASE \n                WHEN metadata->>'type' = 'document' THEN\n                    metadata ? 'timestamp'\n                ELSE true\n            END\n        `\n    ),\n  ]\n);\n\nexport const memoryRelations = relations(memoryTable, ({ one }) => ({\n  embedding: one(embeddingTable),\n}));\n","import type { MessageExample } from '@elizaos/core';\nimport { sql } from 'drizzle-orm';\nimport { boolean, jsonb, pgTable, text, unique, uuid } from 'drizzle-orm/pg-core';\nimport { numberTimestamp } from './types';\n\n/**\n * Represents a table for storing agent data.\n *\n * @type {Table}\n */\nexport const agentTable = pgTable(\n  'agents',\n  {\n    id: uuid('id').primaryKey().defaultRandom(),\n    enabled: boolean('enabled').default(true).notNull(),\n    createdAt: numberTimestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n\n    updatedAt: numberTimestamp('updatedAt')\n      .default(sql`now()`)\n      .notNull(),\n\n    // Character\n    name: text('name').notNull(),\n    username: text('username'),\n    system: text('system').default(''),\n    bio: jsonb('bio')\n      .$type<string | string[]>()\n      .default(sql`'[]'::jsonb`),\n    messageExamples: jsonb('message_examples')\n      .$type<MessageExample[][]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    postExamples: jsonb('post_examples')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    topics: jsonb('topics')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    adjectives: jsonb('adjectives')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    knowledge: jsonb('knowledge')\n      .$type<(string | { path: string; shared?: boolean })[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    plugins: jsonb('plugins')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    settings: jsonb('settings')\n      .$type<{\n        secrets?: { [key: string]: string | boolean | number };\n        [key: string]: unknown;\n      }>()\n      .default(sql`'{}'::jsonb`)\n      .notNull(),\n    style: jsonb('style')\n      .$type<{\n        all?: string[];\n        chat?: string[];\n        post?: string[];\n      }>()\n      .default(sql`'{}'::jsonb`)\n      .notNull(),\n  },\n  (table) => {\n    return {\n      nameUnique: unique('name_unique').on(table.name),\n    };\n  }\n);\n","import { customType } from 'drizzle-orm/pg-core';\n\n/**\n * Represents a custom type for converting a string to a JSONB format and vice versa.\n * @param {Object} options - The options for the custom type.\n * @param {Function} options.dataType - A function that returns the data type as \"jsonb\".\n * @param {Function} options.toDriver - A function that converts a string to a JSON string.\n * @param {Function} options.fromDriver - A function that converts a JSON string back to a string.\n * @returns {Object} - The custom type for string to JSONB conversion.\n */\n\nexport const stringJsonb = customType<{ data: string; driverData: string }>({\n  dataType() {\n    return 'jsonb';\n  },\n  toDriver(value: string): string {\n    return JSON.stringify(value);\n  },\n  fromDriver(value: string): string {\n    return JSON.stringify(value);\n  },\n});\n\n/**\n * Represents a custom type for converting a number to a timestamp string and vice versa.\n * @param {Object} options - The options for the custom type.\n * @param {Function} options.dataType - A function that returns the data type as \"timestamptz\".\n * @param {Function} options.toDriver - A function that converts a number to a timestamp string using the Date object's toISOString method.\n * @param {Function} options.fromDriver - A function that converts a timestamp string to a number using the Date object's getTime method.\n * @returns {Object} - The custom type for number to timestamp conversion.\n */\nexport const numberTimestamp = customType<{ data: number; driverData: string }>({\n  dataType() {\n    return 'timestamptz';\n  },\n  toDriver(value: number): string {\n    return new Date(value).toISOString();\n  },\n  fromDriver(value: string): number {\n    return new Date(value).getTime();\n  },\n});\n","import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, unique, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { numberTimestamp } from './types';\n\n/**\n * Represents an entity table in the database.\n * Includes columns for id, agentId, createdAt, names, and metadata.\n */\nexport const entityTable = pgTable(\n  'entities',\n  {\n    id: uuid('id').notNull().primaryKey(),\n    agentId: uuid('agentId')\n      .notNull()\n      .references(() => agentTable.id, {\n        onDelete: 'cascade',\n      }),\n    createdAt: numberTimestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n    names: text('names')\n      .array()\n      .default(sql`'{}'::text[]`)\n      .notNull(),\n    metadata: jsonb('metadata')\n      .default(sql`'{}'::jsonb`)\n      .notNull(),\n  },\n  (table) => {\n    return {\n      idAgentIdUnique: unique('id_agent_id_unique').on(table.id, table.agentId),\n    };\n  }\n);\n","import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { numberTimestamp } from './types';\nimport { worldTable } from './world';\n\n/**\n * Defines a table schema for 'rooms' in the database.\n *\n * @typedef {object} RoomTable\n * @property {string} id - The unique identifier for the room.\n * @property {string} agentId - The UUID of the agent associated with the room.\n * @property {string} source - The source of the room.\n * @property {string} type - The type of the room.\n * @property {string} serverId - The server ID of the room.\n * @property {string} worldId - The UUID of the world associated with the room.\n * @property {string} name - The name of the room.\n * @property {object} metadata - Additional metadata for the room in JSON format.\n * @property {string} channelId - The channel ID of the room.\n * @property {number} createdAt - The timestamp of when the room was created.\n */\nexport const roomTable = pgTable('rooms', {\n  id: uuid('id')\n    .notNull()\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  agentId: uuid('agentId').references(() => agentTable.id, {\n    onDelete: 'cascade',\n  }),\n  source: text('source').notNull(),\n  type: text('type').notNull(),\n  serverId: text('serverId'),\n  worldId: uuid('worldId'), // no guarantee that world exists, it is optional for now\n  // .references(() => worldTable.id, {\n  //   onDelete: 'cascade',\n  // }),\n  name: text('name'),\n  metadata: jsonb('metadata'),\n  channelId: text('channelId'),\n  createdAt: numberTimestamp('createdAt')\n    .default(sql`now()`)\n    .notNull(),\n});\n","import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, unique, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { numberTimestamp } from './types';\n\n/**\n * Represents a PostgreSQL table for caching data.\n *\n * @type {pgTable}\n */\nexport const cacheTable = pgTable(\n  'cache',\n  {\n    id: uuid('id')\n      .notNull()\n      .primaryKey()\n      .default(sql`gen_random_uuid()`),\n    key: text('key').notNull(),\n    agentId: uuid('agentId')\n      .notNull()\n      .references(() => agentTable.id, { onDelete: 'cascade' }),\n    value: jsonb('value').notNull(),\n    createdAt: numberTimestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n    expiresAt: numberTimestamp('expiresAt'),\n  },\n  (table) => [unique('cache_key_agent_unique').on(table.key, table.agentId)]\n);\n","import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\nimport { numberTimestamp } from './types';\nimport { worldTable } from './world';\n\n/**\n * Definition of a table representing components in the database.\n *\n * @type {Table}\n */\nexport const componentTable = pgTable('components', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  entityId: uuid('entityId')\n    .notNull()\n    .references(() => entityTable.id, { onDelete: 'cascade' }),\n  agentId: uuid('agentId')\n    .notNull()\n    .references(() => agentTable.id, { onDelete: 'cascade' }),\n  roomId: uuid('roomId')\n    .notNull()\n    .references(() => roomTable.id, { onDelete: 'cascade' }),\n  worldId: uuid('worldId').references(() => worldTable.id, {\n    onDelete: 'cascade',\n  }),\n  sourceEntityId: uuid('sourceEntityId').references(() => entityTable.id, {\n    onDelete: 'cascade',\n  }),\n  type: text('type').notNull(),\n  data: jsonb('data').default(sql`'{}'::jsonb`),\n  createdAt: numberTimestamp('createdAt')\n    .default(sql`now()`)\n    .notNull(),\n});\n","import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { numberTimestamp } from './types';\n\n/**\n * Represents a table schema for worlds in the database.\n *\n * @type {PgTable}\n */\n\nexport const worldTable = pgTable('worlds', {\n  id: uuid('id')\n    .notNull()\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  agentId: uuid('agentId')\n    .notNull()\n    .references(() => agentTable.id, { onDelete: 'cascade' }),\n  name: text('name').notNull(),\n  metadata: jsonb('metadata'),\n  serverId: text('serverId').notNull(),\n  createdAt: numberTimestamp('createdAt')\n    .default(sql`now()`)\n    .notNull(),\n});\n","import { sql } from 'drizzle-orm';\nimport { foreignKey, jsonb, pgTable, text, uuid } from 'drizzle-orm/pg-core';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\nimport { numberTimestamp } from './types';\n\n/**\n * Represents a PostgreSQL table for storing logs.\n *\n * @type {Table}\n */\n\nexport const logTable = pgTable(\n  'logs',\n  {\n    id: uuid('id').defaultRandom().notNull(),\n    createdAt: numberTimestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n    entityId: uuid('entityId')\n      .notNull()\n      .references(() => entityTable.id),\n    body: jsonb('body').notNull(),\n    type: text('type').notNull(),\n    roomId: uuid('roomId')\n      .notNull()\n      .references(() => roomTable.id, { onDelete: 'cascade' }),\n  },\n  (table) => [\n    foreignKey({\n      name: 'fk_room',\n      columns: [table.roomId],\n      foreignColumns: [roomTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user',\n      columns: [table.entityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n","import { sql } from 'drizzle-orm';\nimport { foreignKey, index, pgTable, text, unique, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\nimport { numberTimestamp } from './types';\n\n/**\n * Defines the schema for the \"participants\" table in the database.\n *\n * @type {import('knex').TableBuilder}\n */\nexport const participantTable = pgTable(\n  'participants',\n  {\n    id: uuid('id')\n      .notNull()\n      .primaryKey()\n      .default(sql`gen_random_uuid()`),\n    createdAt: numberTimestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n    entityId: uuid('entityId').references(() => entityTable.id, {\n      onDelete: 'cascade',\n    }),\n    roomId: uuid('roomId').references(() => roomTable.id, {\n      onDelete: 'cascade',\n    }),\n    agentId: uuid('agentId').references(() => agentTable.id, {\n      onDelete: 'cascade',\n    }),\n    roomState: text('roomState'),\n  },\n  (table) => [\n    // unique(\"participants_user_room_agent_unique\").on(table.entityId, table.roomId, table.agentId),\n    index('idx_participants_user').on(table.entityId),\n    index('idx_participants_room').on(table.roomId),\n    foreignKey({\n      name: 'fk_room',\n      columns: [table.roomId],\n      foreignColumns: [roomTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user',\n      columns: [table.entityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n","import { sql } from 'drizzle-orm';\nimport { foreignKey, index, jsonb, pgTable, text, unique, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { entityTable } from './entity';\nimport { numberTimestamp } from './types';\n\n/**\n * Defines the relationshipTable containing information about relationships between entities and agents.\n * @type {import('knex').TableBuilder}\n */\nexport const relationshipTable = pgTable(\n  'relationships',\n  {\n    id: uuid('id')\n      .notNull()\n      .primaryKey()\n      .default(sql`gen_random_uuid()`),\n    createdAt: numberTimestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n    sourceEntityId: uuid('sourceEntityId')\n      .notNull()\n      .references(() => entityTable.id, { onDelete: 'cascade' }),\n    targetEntityId: uuid('targetEntityId')\n      .notNull()\n      .references(() => entityTable.id, { onDelete: 'cascade' }),\n    agentId: uuid('agentId')\n      .notNull()\n      .references(() => agentTable.id, { onDelete: 'cascade' }),\n    tags: text('tags').array(),\n    metadata: jsonb('metadata'),\n  },\n  (table) => [\n    index('idx_relationships_users').on(table.sourceEntityId, table.targetEntityId),\n    unique('unique_relationship').on(table.sourceEntityId, table.targetEntityId, table.agentId),\n    foreignKey({\n      name: 'fk_user_a',\n      columns: [table.sourceEntityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user_b',\n      columns: [table.targetEntityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n","import { jsonb, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { sql } from 'drizzle-orm';\n\n/**\n * Represents a table schema for tasks in the database.\n *\n * @type {PgTable}\n */\nexport const taskTable = pgTable('tasks', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  name: text('name').notNull(),\n  description: text('description'),\n  roomId: uuid('roomId'),\n  worldId: uuid('worldId'),\n  entityId: uuid('entityId'),\n  agentId: uuid('agent_id').notNull(),\n  tags: text('tags')\n    .array()\n    .default(sql`'{}'::text[]`),\n  metadata: jsonb('metadata').default(sql`'{}'::jsonb`),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),\n});\n","import { type UUID, logger } from '@elizaos/core';\nimport { type NodePgDatabase, drizzle } from 'drizzle-orm/node-postgres';\nimport { BaseDrizzleAdapter } from '../base';\nimport { DIMENSION_MAP, type EmbeddingDimensionColumn } from '../schema/embedding';\nimport type { PostgresConnectionManager } from './manager';\nimport { type Pool as PgPool } from 'pg';\n\n/**\n * Adapter class for interacting with a PostgreSQL database.\n * Extends BaseDrizzleAdapter<NodePgDatabase>.\n */\nexport class PgDatabaseAdapter extends BaseDrizzleAdapter<NodePgDatabase> {\n  protected embeddingDimension: EmbeddingDimensionColumn = DIMENSION_MAP[384];\n\n  /**\n   * Constructor for creating a new instance of a class.\n   * @param {UUID} agentId - The unique identifier for the agent.\n   * @param {PostgresConnectionManager} manager - The Postgres connection manager for the instance.\n   */\n  constructor(\n    agentId: UUID,\n    private manager: PostgresConnectionManager\n  ) {\n    super(agentId);\n    this.manager = manager;\n  }\n\n  /**\n   * Executes the provided operation with a database connection.\n   *\n   * @template T\n   * @param {() => Promise<T>} operation - The operation to be executed with the database connection.\n   * @returns {Promise<T>} A promise that resolves with the result of the operation.\n   */\n  protected async withDatabase<T>(operation: () => Promise<T>): Promise<T> {\n    return await this.withRetry(async () => {\n      const client = await this.manager.getClient();\n      try {\n        const db = drizzle(client);\n        this.db = db;\n\n        return await operation();\n      } finally {\n        client.release();\n      }\n    });\n  }\n\n  /**\n   * Asynchronously initializes the PgDatabaseAdapter by running migrations using the manager.\n   * Logs a success message if initialization is successful, otherwise logs an error message.\n   *\n   * @returns {Promise<void>} A promise that resolves when initialization is complete.\n   */\n  async init(): Promise<void> {\n    try {\n      await this.manager.runMigrations();\n      logger.debug('PgDatabaseAdapter initialized successfully');\n    } catch (error) {\n      logger.error('Failed to initialize PgDatabaseAdapter:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Asynchronously closes the manager associated with this instance.\n   *\n   * @returns A Promise that resolves once the manager is closed.\n   */\n  async close(): Promise<void> {\n    await this.manager.close();\n  }\n\n  /**\n   * Asynchronously retrieves the connection from the manager.\n   *\n   * @returns {Promise<PgPool>} A Promise that resolves with the connection.\n   */\n  async getConnection() {\n    return this.manager.getConnection();\n  }\n}\n"],"mappings":"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","names":["logger","logger","sql","sql","check","foreignKey","index","pgTable","uuid","vector","sql","boolean","jsonb","pgTable","text","uuid","sql","jsonb","pgTable","text","unique","uuid","pgTable","uuid","sql","text","jsonb","unique","sql","jsonb","pgTable","text","uuid","pgTable","uuid","sql","text","jsonb","pgTable","uuid","text","sql","jsonb","boolean","pgTable","uuid","sql","vector","check","index","foreignKey","sql","jsonb","pgTable","text","unique","uuid","pgTable","uuid","sql","text","jsonb","unique","sql","jsonb","pgTable","text","uuid","sql","jsonb","pgTable","text","uuid","pgTable","uuid","sql","text","jsonb","pgTable","uuid","text","jsonb","sql","sql","foreignKey","jsonb","pgTable","text","uuid","pgTable","uuid","sql","jsonb","text","foreignKey","sql","foreignKey","index","pgTable","text","uuid","pgTable","uuid","sql","text","index","foreignKey","sql","foreignKey","index","jsonb","pgTable","text","unique","uuid","pgTable","uuid","sql","text","jsonb","index","unique","foreignKey","jsonb","pgTable","text","uuid","sql","count","unique","sql","logger","logger","drizzle","drizzle","logger","logger"]}